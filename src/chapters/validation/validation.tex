\chapter[\texorpdfstring{PYCKET AS A FULL RACKET RUN-TIME: CORRECTNESS \& COMPLETENESS}
                          {5. Validation}]{PYCKET AS A FULL RACKET RUN-TIME: CORRECTNESS \& COMPLETENESS}

	\label{chapter:validation}

	\begin{chaptersynopsis}[Chapter Synopsis - \emph{Chapter Content: 10\%}]

        We demonstrate three things in this chapter:

        1. Self-hosted implementation of Racket on Pycket works.

        2. Semantics of the self-hosted Racket on Pycket are identical to the semantics of Racket on Chez Scheme (Racket's own default runtime).

        3. You can evaluate on Pycket anything you can express in Racket.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Correctness by Construction

                Semantics of the self-hosted Racket on Pycket are identical to the semantics of Racket on Chez Scheme (Racket's own default runtime).
			\item Completeness under Self-Hosting

                Pycket can evaluate any \#lang that Racket can evaluate.
		\end{itemize}
    \end{chaptersynopsis}

	\paragraph{}% 1
		In this chapter, we demonstrate that Pycket's self-hosted implementation of Racket is both correct and complete with respect to the original Racket implementation. Correctness here means that the semantics provided by Pycket exactly match those provided by Racket's default runtime on Chez Scheme, and completeness means that any program expressible in Racket can be successfully evaluated by Pycket. Establishing these two properties is essential to demonstrate that Pycket can indeed serve as a fully functional drop-in replacement for Racket.

	\paragraph{}% 2
		As the first step of our validation, we use a moderately sized program, shown in \figref{fig:pycket-works-big-example}, as an example to illustrate that Pycket's runtime behavior is indistinguishable from Racket running on Chez Scheme. This program works correctly on both implementations.

	\inputFigure{validation}{big-example}

	\paragraph{}% 3
		For the program in \figref{fig:pycket-works-big-example} to correctly run on Pycket, multiple essential components must function together seamlessly. At the outset, Pycket must support the full loading and evaluation of a \racketcode{#lang racket} module, which alone involves significant runtime support for nearly all Racket core values and data structures. This includes handling numerical values, strings, symbols, hash tables, vectors, boxes, and particularly structs, which are fundamental to syntax objects used extensively by Racket’s macro expander. Indeed, before considering linklets, Pycket must already have robust runtime support for syntax objects—heavily reliant on Racket structs—to correctly handle macros such as \racketcode{define-syntax}, \racketcode{syntax-case}, and phase-level forms like \racketcode{for-syntax}. Moreover, because the macro expander itself utilizes linklets to manage dependencies across different compilation phases, Pycket must correctly instantiate and evaluate these linklets, ensuring accurate handling of variable binding, closures, and across-phase interactions. Additionally, to correctly evaluate advanced control-flow mechanisms such as \racketcode{shift0} and \racketcode{reset0}, Pycket's runtime must provide reliable and efficient support for delimited continuations. Further, the runtime must comprehensively support primitive operations required by the fully expanded program, including boxing/unboxing operations, structural equality checks, and errors. Since Pycket successfully executes this substantial program, it demonstrates the correctness and completeness of Pycket’s implementation of all these interdependent components.

	\paragraph{}% 4
		The semantic equivalence between Racket running on Chez Scheme and Pycket ultimately relies on Pycket's correct handling of the linklet semantics, as well as the correctness of its primitive operations and core data structures exposed to linklets. Given these foundational components, completeness naturally follows from Racket’s layered language architecture, in which richer language constructs and functionalities are incrementally constructed atop more primitive layers. The following two sections detail the evidence supporting both correctness and completeness.

	\section[\texorpdfstring{Correctness by Construction}{Correctness}]{Correctness by Construction}

		\paragraph{}% 1
			Correctness by construction in Pycket begins with an already comprehensive and correct implementation of Racket's core values and data structures. This includes the full numeric tower, symbols, hash tables, vectors, and structs, as described in detail in \cite{pycketmain}. We build our high-level correctness argument upon this robust correctness of these fundamental elements.

		\inputFigure{validation}{test-suites-table}

		\paragraph{}% 2
			Pycket ensures correctness of its primitive operations through an extensive suite of unit tests. \tableRef{table:validation-test-suites-table} shows the number and scope of Pycket's test suites, forming a total of 549 suites, each containing numerous individual test cases. Among all the baseline semantics, these suites comprehensively cover significant runtime components such as structs, hashes, equality, hidden classes, impersonators, regular expressions, \gls{ast} handling, and linklets.

		\paragraph{}% 3
			We considered leveraging Racket’s own comprehensive test suites to further demonstrate Pycket's correctness. However, since Racket’s testing infrastructure heavily relies on external tooling such as \racketcode{raco} (e.g., \racketcode{raco test -p racket-test-core}), integrating it directly into Pycket's testing workflow would exceed the scope of our study. Instead, we focus on targeted, manually adapted tests that precisely verify the critical aspects of our implementation.

		\paragraph{}% 4
			A crucial component of ensuring Pycket’s correctness is validating its implementation of the linklet semantics. The correctness of linklets is particularly important because linklets constitute the primary compilation units upon which Racket's macro expander and module system are constructed. In the rest of the section, we explain the methodology employed to ensure that Pycket correctly implements these semantics, aligning precisely with the semantics defined by Racket itself.

		\paragraph{}% 5
			Recall that the operational semantics we presented for linklets in \chapterRef{chapter:linklet} were developed using PLT Redex, which allows us to create an executable model of these semantics. The complete linklet model is provided in \appendixRef{appendix:linklet-semantics-model-redex-code}. In the remainder of this section, we describe how we leveraged this executable model to validate Pycket’s implementation of linklet semantics.

		\paragraph{}% 6
			To ensure correctness of Pycket's implementation of linklet semantics, we manually adapted Pycket’s own linklet tests into the \racketcode{program} form defined in our PLT Redex model (refer to \figref{fig:linklet-program-source-language} for the definition of the program form). This adaptation enabled us to create a symmetric testing setup, allowing us to run each test across Racket itself, Pycket, and the Redex model simultaneously. Running these tests concurrently ensures that all implementations consistently agree on the expected operational semantics.

		\inputFigure{validation}{test-equal-listing}

		\paragraph{}% 7
			An example test case (adapted from Pycket's suite into the Redex model) for the correctness of linklet semantics is shown in \figref{fig:test-equal-listing}. Here, the linklet \textbf{l2} exports a closure \racketcode{g}, which references a variable \racketcode{y} initially defined as 10 and subsequently mutated to 50 within the linklet (line 9). Since \racketcode{y} is exported and mutated within \textbf{l2}, the compiler treats it as a linklet variable. Similarly, in linklet \textbf{l3}, the identifier \racketcode{y} is exported without a corresponding local definition and is also mutated (line 11), thus compiled as a linklet variable as well. After compilation, we first instantiate \textbf{l2} with the target instance \racketcode{t1} (line 15), populating it with exported variables including the closure \racketcode{g} and the variable \racketcode{y}. We then instantiate \textbf{l3} using the same target instance \racketcode{t1}. Any reference to \racketcode{y} within \textbf{l3} thus accesses and modifies the shared linklet variable in the target instance. At the time \textbf{l3} is instantiated, the value of \racketcode{y} is 50, but before invoking the closure \racketcode{g}, \textbf{l3} updates \racketcode{y} to 200 (line 11). When the closure \racketcode{g} is finally invoked (line 12), it yields a result of 201, highlighting the use of the updated linklet variable \racketcode{y}, despite lexical scoping; otherwise, without linklet variables, the closure would have used the original lexical environment in which \racketcode{y} was 10, returning 11. Notably, after this invocation, the variable \racketcode{y} in the target instance \racketcode{t1} remains modified to 200, which can be confirmed by invoking \racketcode{(instance-variable-value t1 'y)}, demonstrating correct handling of linklet variables across instances.

		\subsection{Randomized Testing for Linklet Semantics}


			\begin{paragraph-here}% 8
				Additonally, the PLT Redex provides comprehensive functionalities for random testing, where it generates random terms based on a given grammar and tests those terms against a given predicate. It essentially tries to find a counterexample that will fail the predicate. We used the random testing for both Racket Core and Linklet models separately, where we essentially asked the question “Does Racket agree with the given model about this term?” for both.
			\end{paragraph-here}

			\begin{paragraph-here}% 9
				In particular, we tested these two predicates, implemented as meta-functions on the languages LKL and Linklets respectively: – eval-rc=racket-core – eval-prog=racket-linklets eval-rc=racket-core is a meta-function that takes a term (in LKL language) as input and applies the racket evaluator and the eval-rc (i.e. RC evaluator) at the same time and checks if they produce the same answer (on an empty environment).
			\end{paragraph-here}

			\begin{paragraph-here}% 10
				One interesting issue was that the redex-check generates random terms based on the given grammar, which in this case the grammar for LKL language (and also the Linklets grammar for random testing of the Linklets model). However, these languages include objects that doesn’t have explicit representations in Racket, such as closure. A closure in both Racket and LKL has formal parameters, body and an environment that it closes on. However, it’s not possible to syntactically produce closures in Racket, since the environment doesn’t have explicit representation. Therefore, a syntactically valid term according to the LKL grammar such as “(closure x (+ x y) ((y cell123)))” doesn’t have a corresponding term in Racket. As a result, any randomly generated term that has an explicit closure in it will raise an exception on the Racket evaluator, while successfully being run on the LKL evaluator.
			\end{paragraph-here}

			\inputFigure{validation}{restricted-lkl-expression-grammar}

			\begin{paragraph-here}% 11
				To address this issue, and decrease the number of errors caused by randomly generated such cases, we restricted the grammar a bit for redex-check to generate terms that will have corresponding terms in the Racket world. Figure shows the restricted expression for the RC. Note that in this case the only difference is that we don’t allow the closures (the non-terminal “c”) to explicitly appear in terms. We have a little more complicated restricted setup for the Linklets, as we will discuss below.f \figref{fig:restricted-lkl-expression}
			\end{paragraph-here}

			\begin{paragraph-here}% 12
				With 1000 randomly generated terms (freshly generated each time we ran the tests), we successfully established that our LKL model agrees with the actual Racket implementation.
			\end{paragraph-here}

			\begin{paragraph-here}% 13
				Testing the Linklets model was a little bit more elaborate than testing the LKL model, for two reasons: 1. Because that the terms are randomly generated, in the Linklets model we had to deal with almost every corner case there is to evaluate linklets. Imagine randomly generating Racket modules based on a full Racket grammar and running them. They would be syntactically valid, but one would expect a plethora of runtime errors from reference to undefined identifiers to arity errors in function applications, or type errors like trying to add a number with a string, etc. 2. Terms of the LKL language are syntactically valid for Racket language too, so we could easily feed the terms to both Racket and RC evaluators without making any changes. However, this is not possible for the Linklets language, since Racket doesn’t know about the program form.
			\end{paragraph-here}

			\inputFigure{validation}{initial-checks-for-test-redex}

			\begin{paragraph-here}% 14
				\figref{fig:restricted-lkl-eval-prog}
				To deal with the former case, where we have lots of semantically invalid test inputs, we had two options. First, to use mechanism like \#:prepare in redex-check, to ensure that a generated term is semantically valid, discard otherwise, without applying the predicate. Second, add checks to the Linklets evaluator to catch and produce errors for the corner cases. While the former is a perfectly good solution for the testing per se, we decided to choose the second option to get the model closer to the actual implementation. This, unfortunately left us with the majority of the test cases being rejected by both systems, as opposed to having them being interesting with respect to the instantiation semantics. However, we expect that to be solved when we further improve the testing with the first option as well. As can be seen in Figure 12 below, we have ahead of time checks for a bunch of error cases. The reason for these checks to be done ahead of time instead of the runtime is that the Racket catches these errors in the function compile-linklet, where it constructs linklet objects from s-expressions, while the Linklet model clearly doesn’t have the compile-linklet since the model is syntax-driven, i.e. the representation is the object itself.
			\end{paragraph-here}

			\inputFigure{validation}{convert-program-to-racket}

			\begin{paragraph-here}% 15
				\figref{fig:convert-program-to-racket}
				To address the second issue, where we can not invoke the Racket evaluator on program forms, we implemented a basic converter to rewrite the program forms to use the Racket forms like let-values, etc. Figure 13 shows such a conversion as an example.

			\end{paragraph-here}

			\inputFigure{validation}{restricted-linklet-program-grammar}

			\begin{paragraph-here}% 16
				\figref{fig:restricted-linklet-program}
				As discussed above for testing the LKL model, another issue with the random testing is generating terms that doesn’t have corresponding terms in the Racket language. As we have shown in Figure 11, we solved this issue by restricting the grammar to generate meaningful terms for the Racket evaluator. We also have a restricted grammar for the Linklets language, as shown in Figure 14.
			\end{paragraph-here}

			\begin{paragraph-here}% 17
				We again removed the explicit closures as values and also removed the explicit terms representing the linklet instances. Because a linklet instance is a mapping from variables to cells, and just like in the case of closure forms, a cell identifier has no corresponding term in Racket. Just as the case for Racket Core model, with an increased number of 2000 each time freshly generated random terms, we successfully demonstrated that our Linklets model agrees with the actual Racket linklet implementation (i.e. racket/linklet).
			\end{paragraph-here}

			\begin{paragraph-here}% 18
				Ensuring the core values and data structures and primitive support, plus the linklet semantics, ensure that Pycket correctly evaluates whatever is expressed by the compiler (the macro expander). On top of this, we add untouched Racket code that brings functionality already tested and working on Racket's own run-time, which acts like integration tests for any run-time that imports those functionalities via linklets.
			\end{paragraph-here}


	\section[\texorpdfstring{Completeness under Self-Hosting}{Completeness}]{Completeness under Self-Hosting}
		\begin{paragraph-here}% 1
			Racket is a programming language programming language.
		\end{paragraph-here}

		\begin{paragraph-here}% 2
			As long as you have the expander to reduce the given language to \#\%kernel, you're golden.
		\end{paragraph-here}

		\begin{paragraph-here}% 3
			From \#\%kernel to \#lang racket/base, you need primitives, data structures, etc .........
		\end{paragraph-here}

		\begin{paragraph-here}% 4
			Being able to implement \#lang racket/base is a good springboard to implement larger languages.
		\end{paragraph-here}

		\begin{paragraph-here}% 5
			Beyond \#lang racket/base, you need the full power of the macro expander and the module language
		\end{paragraph-here}

		\begin{paragraph-here}% 6
			We showed in the figure at the very beginning that Pycket can run a `\#lang racket` program, confirming our opening claim: Pycket behaves as a drop-in, functionally transparent, self-hosting Racket runtime.
		\end{paragraph-here}

