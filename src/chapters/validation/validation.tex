\chapter[\texorpdfstring{PYCKET AS A FULL RACKET RUN-TIME: CORRECTNESS \& COMPLETENESS}
                          {5. Validation}]{PYCKET AS A FULL RACKET RUN-TIME: CORRECTNESS \& COMPLETENESS}

	\label{chapter:validation}

	\begin{chaptersynopsis}[Chapter Synopsis - \emph{Chapter Content: 10\%}]

        We demonstrate three things in this chapter:

        1. Self-hosted implementation of Racket on Pycket works.

        2. Semantics of the self-hosted Racket on Pycket are identical to the semantics of Racket on Chez Scheme (Racket's own default runtime).

        3. You can evaluate on Pycket anything you can express in Racket.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Correctness by Construction

                Semantics of the self-hosted Racket on Pycket are identical to the semantics of Racket on Chez Scheme (Racket's own default runtime).
			\item Completeness under Self-Hosting

                Pycket can evaluate any \#lang that Racket can evaluate.
		\end{itemize}
    \end{chaptersynopsis}

	\paragraph{}% 1
		In this chapter, we demonstrate that Pycket's self-hosted implementation of Racket is both correct and complete with respect to the original Racket implementation. Correctness here means that the semantics provided by Pycket exactly match those provided by Racket's default runtime on Chez Scheme, and completeness means that any program expressible in Racket can be successfully evaluated by Pycket. Establishing these two properties is essential to demonstrate that Pycket can indeed serve as a fully functional drop-in replacement for Racket.

	\paragraph{}% 2
		As the first step of our validation, we use a moderately sized program, shown in \figref{fig:pycket-works-big-example}, as an example to illustrate that Pycket's runtime behavior is indistinguishable from Racket running on Chez Scheme. This program works correctly on both implementations.

	\inputFigure{validation}{big-example}

	\paragraph{}% 3
		For the program in \figref{fig:pycket-works-big-example} to correctly run on Pycket, multiple essential components must function together seamlessly. At the outset, Pycket must support the full loading and evaluation of a \racketcode{#lang racket} module, which alone involves significant runtime support for nearly all Racket core values and data structures. This includes handling numerical values, strings, symbols, hash tables, vectors, boxes, and particularly structs, which are fundamental to syntax objects used extensively by Racket’s macro expander. Indeed, before considering linklets, Pycket must already have robust runtime support for syntax objects—heavily reliant on Racket structs—to correctly handle macros such as \racketcode{define-syntax}, \racketcode{syntax-case}, and phase-level forms like \racketcode{for-syntax}. Moreover, because the macro expander itself utilizes linklets to manage dependencies across different compilation phases, Pycket must correctly instantiate and evaluate these linklets, ensuring accurate handling of variable binding, closures, and across-phase interactions. Additionally, to correctly evaluate advanced control-flow mechanisms such as \racketcode{shift0} and \racketcode{reset0}, Pycket's runtime must provide reliable and efficient support for delimited continuations. Further, the runtime must comprehensively support primitive operations required by the fully expanded program, including boxing/unboxing operations, structural equality checks, and errors. Since Pycket successfully executes this substantial program, it demonstrates the correctness and completeness of Pycket’s implementation of all these interdependent components.

	\paragraph{}% 4
		The semantic equivalence between Racket running on Chez Scheme and Pycket ultimately relies on Pycket's correct handling of the linklet semantics, as well as the correctness of its primitive operations and core data structures exposed to linklets. Given these foundational components, completeness naturally follows from Racket’s layered language architecture, in which richer language constructs and functionalities are incrementally constructed atop more primitive layers. The following two sections detail the evidence supporting both correctness and completeness.

	\section[\texorpdfstring{Correctness by Construction}{Correctness}]{Correctness by Construction}

		\begin{paragraph-here}% 1
			Luckily, we start with already correct core values and data structures (number tower, symbols, hash tables, vectors, structs..).
		\end{paragraph-here}

		\inputFigure{validation}{test-suites-table}

		\begin{paragraph-here}% 2
			The correction for the primitives is made sure by unit tests. Pycket has an extensive test suite. \tableRef{table:validation-test-suites-table}
		\end{paragraph-here}

		\begin{paragraph-here}% 3
			We considered running Racket's own tests on Pycket, however, Racket's testing mechanism is built on `raco` (e.g. `raco test -p racket-test-core`), and integrating external tooling into Pycket would be beyond the scope of our study.
		\end{paragraph-here}

		\subsection{Randomized Testing for Linklet Semantics}
			\begin{paragraph-here}% 4
				Correctness in this setup also depends on the correctness of the linklet semantics being implemented correctly. In the rest of the section we'll detail how we made sure of that.
			\end{paragraph-here}

			\begin{paragraph-here}% 5
				Recall that the operational semantics we presented for linklets at the chapter:linklet is developed in executable PLT Redex, the model is in the appendix whatever...
			\end{paragraph-here}

			\begin{paragraph-here}% 6
				To ensure correctness of linklet semantics, we manually adapted Pycket's own tests for linklets into the program form in the Redex model to have a symmetric setup (refer to chapter:linklet / or figure for the "program" form). In the end, we ran these tests on Racket itself, Pycket and on the Redex model simultaneously, which made sure everyone agree about the operational semantics, and all the test pass everywhere.
			\end{paragraph-here}

			\inputFigure{validation}{test-equal-listing}

			\begin{paragraph-here}% 7
				Figure \figref{fig:test-equal-listing} shows one of those test cases as an example, where the linklet l2 exports a closure that has a free variable “y” inside, defined as 10 at the time of closure creation. We start by filling the target t1 with the variables that l2 exports, including the closure “g”, and use the same target t1 in instantiating the linklet l3. The linklet l3 exports the undefined variable “y”, and because that the target t1 now has the variable “y”, it uses the target’s variable. l3 sets the variable to 200 and invokes the closure. Thanks to lexical scope, the closure uses the environment that it captures at the time of its creation, which had the value 10 for the variable “y”. However that variable “y” is now modified to be 200, therefore the result is 201, instead of 11. Note that the value for “y” inside the target has been modified too, so (instance-variable-value t1 ’y) would give us 200.
			\end{paragraph-here}

			\begin{paragraph-here}% 8
				Additonally, the PLT Redex provides comprehensive functionalities for random testing, where it generates random terms based on a given grammar and tests those terms against a given predicate. It essentially tries to find a counterexample that will fail the predicate. We used the random testing for both Racket Core and Linklet models separately, where we essentially asked the question “Does Racket agree with the given model about this term?” for both.
			\end{paragraph-here}

			\begin{paragraph-here}% 9
				In particular, we tested these two predicates, implemented as meta-functions on the languages LKL and Linklets respectively: – eval-rc=racket-core – eval-prog=racket-linklets eval-rc=racket-core is a meta-function that takes a term (in LKL language) as input and applies the racket evaluator and the eval-rc (i.e. RC evaluator) at the same time and checks if they produce the same answer (on an empty environment).
			\end{paragraph-here}

			\begin{paragraph-here}% 10
				One interesting issue was that the redex-check generates random terms based on the given grammar, which in this case the grammar for LKL language (and also the Linklets grammar for random testing of the Linklets model). However, these languages include objects that doesn’t have explicit representations in Racket, such as closure. A closure in both Racket and LKL has formal parameters, body and an environment that it closes on. However, it’s not possible to syntactically produce closures in Racket, since the environment doesn’t have explicit representation. Therefore, a syntactically valid term according to the LKL grammar such as “(closure x (+ x y) ((y cell123)))” doesn’t have a corresponding term in Racket. As a result, any randomly generated term that has an explicit closure in it will raise an exception on the Racket evaluator, while successfully being run on the LKL evaluator.
			\end{paragraph-here}

			\inputFigure{validation}{restricted-lkl-expression-grammar}

			\begin{paragraph-here}% 11
				To address this issue, and decrease the number of errors caused by randomly generated such cases, we restricted the grammar a bit for redex-check to generate terms that will have corresponding terms in the Racket world. Figure shows the restricted expression for the RC. Note that in this case the only difference is that we don’t allow the closures (the non-terminal “c”) to explicitly appear in terms. We have a little more complicated restricted setup for the Linklets, as we will discuss below.f \figref{fig:restricted-lkl-expression}
			\end{paragraph-here}

			\begin{paragraph-here}% 12
				With 1000 randomly generated terms (freshly generated each time we ran the tests), we successfully established that our LKL model agrees with the actual Racket implementation.
			\end{paragraph-here}

			\begin{paragraph-here}% 13
				Testing the Linklets model was a little bit more elaborate than testing the LKL model, for two reasons: 1. Because that the terms are randomly generated, in the Linklets model we had to deal with almost every corner case there is to evaluate linklets. Imagine randomly generating Racket modules based on a full Racket grammar and running them. They would be syntactically valid, but one would expect a plethora of runtime errors from reference to undefined identifiers to arity errors in function applications, or type errors like trying to add a number with a string, etc. 2. Terms of the LKL language are syntactically valid for Racket language too, so we could easily feed the terms to both Racket and RC evaluators without making any changes. However, this is not possible for the Linklets language, since Racket doesn’t know about the program form.
			\end{paragraph-here}

			\inputFigure{validation}{initial-checks-for-test-redex}

			\begin{paragraph-here}% 14
				\figref{fig:restricted-lkl-eval-prog}
				To deal with the former case, where we have lots of semantically invalid test inputs, we had two options. First, to use mechanism like \#:prepare in redex-check, to ensure that a generated term is semantically valid, discard otherwise, without applying the predicate. Second, add checks to the Linklets evaluator to catch and produce errors for the corner cases. While the former is a perfectly good solution for the testing per se, we decided to choose the second option to get the model closer to the actual implementation. This, unfortunately left us with the majority of the test cases being rejected by both systems, as opposed to having them being interesting with respect to the instantiation semantics. However, we expect that to be solved when we further improve the testing with the first option as well. As can be seen in Figure 12 below, we have ahead of time checks for a bunch of error cases. The reason for these checks to be done ahead of time instead of the runtime is that the Racket catches these errors in the function compile-linklet, where it constructs linklet objects from s-expressions, while the Linklet model clearly doesn’t have the compile-linklet since the model is syntax-driven, i.e. the representation is the object itself.
			\end{paragraph-here}

			\inputFigure{validation}{convert-program-to-racket}

			\begin{paragraph-here}% 15
				\figref{fig:convert-program-to-racket}
				To address the second issue, where we can not invoke the Racket evaluator on program forms, we implemented a basic converter to rewrite the program forms to use the Racket forms like let-values, etc. Figure 13 shows such a conversion as an example.

			\end{paragraph-here}

			\inputFigure{validation}{restricted-linklet-program-grammar}

			\begin{paragraph-here}% 16
				\figref{fig:restricted-linklet-program}
				As discussed above for testing the LKL model, another issue with the random testing is generating terms that doesn’t have corresponding terms in the Racket language. As we have shown in Figure 11, we solved this issue by restricting the grammar to generate meaningful terms for the Racket evaluator. We also have a restricted grammar for the Linklets language, as shown in Figure 14.
			\end{paragraph-here}

			\begin{paragraph-here}% 17
				We again removed the explicit closures as values and also removed the explicit terms representing the linklet instances. Because a linklet instance is a mapping from variables to cells, and just like in the case of closure forms, a cell identifier has no corresponding term in Racket. Just as the case for Racket Core model, with an increased number of 2000 each time freshly generated random terms, we successfully demonstrated that our Linklets model agrees with the actual Racket linklet implementation (i.e. racket/linklet).
			\end{paragraph-here}

			\begin{paragraph-here}% 18
				Ensuring the core values and data structures and primitive support, plus the linklet semantics, ensure that Pycket correctly evaluates whatever is expressed by the compiler (the macro expander). On top of this, we add untouched Racket code that brings functionality already tested and working on Racket's own run-time, which acts like integration tests for any run-time that imports those functionalities via linklets.
			\end{paragraph-here}


	\section[\texorpdfstring{Completeness under Self-Hosting}{Completeness}]{Completeness under Self-Hosting}
		\begin{paragraph-here}% 1
			Racket is a programming language programming language.
		\end{paragraph-here}

		\begin{paragraph-here}% 2
			As long as you have the expander to reduce the given language to \#\%kernel, you're golden.
		\end{paragraph-here}

		\begin{paragraph-here}% 3
			From \#\%kernel to \#lang racket/base, you need primitives, data structures, etc .........
		\end{paragraph-here}

		\begin{paragraph-here}% 4
			Being able to implement \#lang racket/base is a good springboard to implement larger languages.
		\end{paragraph-here}

		\begin{paragraph-here}% 5
			Beyond \#lang racket/base, you need the full power of the macro expander and the module language
		\end{paragraph-here}

		\begin{paragraph-here}% 6
			We showed in the figure at the very beginning that Pycket can run a `\#lang racket` program, confirming our opening claim: Pycket behaves as a drop-in, functionally transparent, self-hosting Racket runtime.
		\end{paragraph-here}

