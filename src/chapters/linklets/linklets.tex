\chapter[\texorpdfstring{PROGRAMMING LANGUAGES \& PORTABILITY}
                          {Linklets}]{PROGRAMMING LANGUAGES \& PORTABILITY}
\label{chapter:linklets}

	\begin{chaptersynopsis}

        Making programming languages more portable is good, and here's a way to do that.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Enriching Compiler \& Runtime Communication

                Motivation for linklets. Making programming languages more portable is good.
			\item Linklets as Units of Compilation

                Operational semantics for linklets, both formalism and PLT Redex model.

				Linklets are good tools to improve communication between the compiler and runtime.
		\end{itemize}
    \end{chaptersynopsis}

	\paragraph{}%
  		A practical programming language typically consists of three essential components: first, a \emph{language grammar} defining the syntax—expressions that can be formed; second, \emph{core language semantics}, which determine the meaning of these expressions, typically via reduction rules mapping expressions to values; and third, a \emph{runtime} responsible for realizing these semantics on a computing environment. The runtime provides mechanisms to read and expand user expressions, evaluate them, and produce values, effectively bridging the gap between abstract language semantics and concrete execution.

	\paragraph{}%
  		The \emph{portability} of a programming language refers to its ability to be adapted to run on different runtimes or virtual machines. This notion is distinct from having multiple independent implementations of a language. Rather, portability implies deliberate support at the language's syntax or semantic level, enabling runtimes to more easily adopt the language's core implementation. Languages that explicitly expose an intermediate form or semantics conducive to plugging into different backend runtimes exemplify this approach. Notable examples include Haskell, whose \gls{ghc} toolchain reduces every module to an intermediate typed Core IR, facilitating easy backend integration such as LLVM~\cite{ghc_llvm_backend}; and Common Lisp, particularly implementations like Clasp, which retain high-level runtime elements (macro expander, reader) in Lisp while swapping only the code generator~\cite{clasp_llvm}. Such designs demonstrate how exposing an intermediate representation at the language level significantly simplifies retargeting efforts, reducing engineering overhead.


	\paragraph{Future-proofing and platform agility}%
		When language semantics are lowered to a portable, implementation-independent \gls{ir}, targeting new \glspl{vm} typically involves writing a minimal backend rather than a complete compiler. For instance, the \gls{ghc} gained support for ARM, PowerPC, and WebAssembly virtually \smartQL for free\smartQR upon integrating LLVM~\cite{ghc_llvm_backend}. Reducing engineering costs per new target ensures the language remains viable across evolving hardware ecosystems, preserving the investments made by implementers and users.

	\paragraph{Tooling \& ecosystem leverage}%
		A standardized, information-rich IR allows external tools—such as optimizers, verifiers, and profilers—to uniformly support all eventual backends. Compiler research demonstrates that most optimization efforts naturally gravitate toward the IR layer because benefits propagate globally~\cite{ir_cacm}. Recent advances, such as the SMACK verifier, illustrate that languages emitting LLVM \gls{ir} immediately gain powerful, cross-language verification capabilities without rewriting analysis tools for each source language~\cite{llvm_verification}. Hence, language-level portability not only expands the range of deployment targets but also enhances the reuse potential of infrastructure and tooling around the language.

	\paragraph{}%
  		Improving language portability fundamentally relies on enhancing semantic communication between the language's core semantics and its runtime. Clear, explicit interfaces or intermediate representations are required for languages to effectively instruct runtimes on realizing their semantics, rather than each runtime manually handling tight couplings such as macro expansion, serialization, or user-level threading models.

	\paragraph{}%
		In this chapter, we examine improvements to language portability, using Racket's linklets as a concrete example. We introduce a formal specification along with an executable PLT Redex model to describe the operational semantics of linklets. This formalism forms the basis for understanding how self-hosting is achieved in the meta-tracing JIT-compiled Pycket implementation described in \chapterRef{chapter:pycket}, supporting the main thesis statement.


	\section[\texorpdfstring{Enriching Compiler \& Runtime Communication}{Motivation for Linklets}]{Enriching Compiler \& Runtime Communication}

		\paragraph{}%
			A tight coupling exists between the runtime and the reduction semantics of a programming language. This coupling arises because the runtime must concretely implement the abstract semantics specified by the language. For example, languages with macro systems may require runtimes to adopt specialized parsing mechanisms to handle macro expansions, differing from standard reading approaches. Similarly, custom serialization semantics defined by a language necessitate that the runtime can correctly serialize and deserialize language-specific objects. Additionally, languages that define semantics for user-level (green) threads demand explicit runtime support for mapping these constructs to \gls{os} threads. Clearly specifying these interactions is essential for streamlined and efficient language implementations.

		\paragraph{}%
			Without explicit support from the language itself, each runtime that aims to implement the language must manually reconstruct all of these intricate interactions. Such manual reconstruction is costly, error-prone, and challenging to maintain, especially since subtle changes in language semantics often require extensive adjustments within the runtime. Consequently, portability becomes limited, forcing each runtime to independently handle the complexities inherent in language semantics. Therefore, introducing a mechanism to mitigate these difficulties would significantly improve portability.

		\paragraph{}%
			Racket is a good example that successfully leverages such a mechanism to significantly enhance its portability. In 2019, Racket transitioned to Chez Scheme as its primary runtime and introduced a structured intermediate representation called \emph{linklets} as units of compilation, designed to simplify the runtime implementation~\cite{icfp2019}. Linklets, discussed in detail in the next section, streamlined the process of re-targeting Racket to Chez Scheme and established a robust foundation for self-hosting on other platforms, directly aligning with our thesis.

		\inputFigure{linklets}{racket-on-chez-3-stacks-figure}

		\paragraph{}%
			The transition of Racket to Chez Scheme is illustrated in \figref{fig:racket-on-chez}. To concretely improve portability, Racket shifted several high-level components—initially and most notably the macro expander—from a C-based implementation to Racket itself. The left-most column of \figref{fig:racket-on-chez} highlights the first ever version of Racket with its expander implemented in Racket. The macro expander defines critical functionality, including the macro system, module system, reader, and code expansion and elaboration. It is the essential component enabling reading and elaborating Racket code, thereby it plays a central role in supporting self-hosting of the language.

		\inputFigure{linklets}{racket-expand-example-figure}

		\paragraph{}%
			Furthermore, the expander transforms Racket code into a core \gls{ir} designed explicitly for consumption by the hosting runtime. This intermediate representation closely resembles $\lambda$-calculus with some syntactic extensions. Instead of conventional \racketcode{lambda} forms, which consume and produce values, this intermediate form employs \racketcode{linklet} forms that consume and produce potentially mutable variables. By strictly segregating evaluation phases (e.g., compile-time versus run-time), the expander produces distinct linklets corresponding to different phases for a given Racket module. \figref{fig:racket-expand-example} demonstrates this elaboration with an example module, showing distinct linklets for expansion-time (compile-time), run-time, and literal syntax objects to bridge these phases.

		\paragraph{}%
			The bundle of linklets generated for a Racket module can subsequently be flattened into a single, self-contained runtime linklet. This way, Racket applies the macro expander to each layer of high-level functionality to produce self-contained linklets that can be exported offline by the language. For example, applying the macro expander to itself produces an independent linklet that encapsulates all subsystems essential for bootstrapping Racket, such as the module and macro systems. We will refer to the high-level functionalities that are exported in this way together as the \emph{bootstrapping linklets} in the rest of the dissertation.

		\paragraph{}%
			Given the bootstrapping linklets, a runtime that aims to implement Racket needs only to understand how to compile and execute serialized linklets to turn into a full runtime for the language. By loading these linklets, a runtime instantly acquires Racket's entire high-level functionalities, such as the macro and module system, \racketcode{read}, \racketcode{expand}, and more without having to explicitly reimplement them separately. Consequently, it gains the capacity to self-host Racket, by utilizing the module system to locate and load the core Racket libraries, and reading and expanding all the modules to load a Racket language (e.g. \emph{racket/base}), fully supporting Racket’s semantics. In \chapterRef{chapter:pycket} we present this process in detail by which we turn Pycket into a full Racket implementation.

		\paragraph{}%
			In the next section, we delve into the semantics of the central construct enabling this enhanced portability—linklets. We present a formal operational semantics for linklets and describe an executable PLT Redex model that captures their compilation and execution semantics.


	\section[\texorpdfstring{Linklets as Units of Compilation}{Semantics for Linklets}]{Linklets as Units of Compilation}
		\label{section:linklet-semantics}

		\begin{mainpoint}
			Semantics for linklets.

			Linklets are good tools to improve communication between the compiler and runtime.
		\end{mainpoint}

		\begin{paragraph-here}
			In this section, we introduce linklets as a language form and provide formal operational semantics, the minimal API for a VM to implement to support linklets, along with a practical example of how they implement an interesting functionality.
		\end{paragraph-here}

		\inputFigure{linklets}{linklet-source-language-figure}

		\begin{paragraph-here}
			A \emph{linklet}, as a language form, is a lambda-like binding form that consists of four main components, as can be seen in \figref{fig:linklet-grammar}:

			\begin{itemize}
				\item A set of imported variables.
				\item A set of exported variables.
				\item A body that consists of variable definitions and expressions.
			\end{itemize}

			Some real-life s-expressions for linklets can be seen in \figref{fig:racket-expand-example}. The set of imported variables brings in variables from other linklets, while the exported make variables available to other linklets. One of the key things that allows linklets to do interesting things is that the set of exported variables can have some variables that have no corresponding definitions in the body. [<-- cliffhanger for next paragraph]
		\end{paragraph-here}

		Instead of consuming and producing values like a regular lambda form, linklets consume and produce variables that are potentially mutable.

		\begin{paragraph-here}
			Linklets as s-expressions by themselves are as much interesting as an s-expression for a \racketcode{lambda} form. But when \emph{compiled} by a hosting runtime into a linklet object, a linklet becomes ready for \emph{instantiation}. Instantiating a linklet is essentially very similar to a function application with some extra bookkeeping regarding the imported and exported variables, eventually running the expressions within the body.


			The purpose of a linklet instantiation is to produce a \emph{linklet instance}, which is a mapping of variables to values, plus some additional data.

			What do you do with it? Basic instantiation semantics.. figure 3 from quals.
		\end{paragraph-here}

		To run a linklet, it is instantiated as a linklet instance, which is a container for a set of linklet variables and some other data (e.g. namespace). When a linklet is instantiated, it receives other linklet instances for its imports, and it extracts a specified set of variables that are exported from each of the given instances. The newly created linklet instance provides its exported variables for use by other linklets. Moreover, an instantiation may be given an additional linklet instance as an input, namely the target instance. In this case, the variables in the target instance is used and modified for the linklet definitions and expressions during the evaluation of the body expressions, and the result is the value of the last expression in the linklet (instead of an instance). In the remainder of this document we will use the names “targeted instantiation” and “regular instantiation” for these two modes. \figref{fig:basic-linklet-instantiation}


		\inputFigure{linklets}{basic-linklet-instantiation-figure}



		\subsection{Operational Example: A Small Top-level REPL Interaction}

		\begin{paragraph-here}
			Before we jump in to the operational semantics, let's go over an example to see how they work internally to implement a top-level repl.

			Let’s take a look at how a VM that implements linklets can easily implement functionalities such as the Racket top-level repl3 by loading the expander linklet into its run-time. Note that the top-level itself is quite complicated and beyond the scope of our study. The example here aims to provide a general overview of the interaction between the run-time and the functionalities provided by the language through the linklets, for this exercise in particular the expander linklet. Recall that the expander implements functions such as read, expand, eval, and outputs a bundle of linklets for a given Racket code. Let’s first briefly describe what linklets are and how linklets operate. In Section 3.2.2 I will provide linklets’ operational semantics with a formalism in more detail.
		\end{paragraph-here}


		\begin{paragraph-here}
			The minimal API for a virtual machine to implement the linklets consists of the functions i) compile-linklet for preparing a linklet for instantiation and ii) instantiate-linklet for running a compiled linklet. In particular, the VM uses the compile-linklet to take an s-expression for a linklet as input and produce a linklet object in a representation of its choice, containing the run-time AST for the codes inside the linklet. Therefore, loading a linklet into its run-time for a VM means that the functions provided by the linklet are callable during the run-time. For example after loading the expander linklet, a VM can call the functions from Racket’s expander such as read, expand, eval to use Racket’s module system, macro system etc.
		\end{paragraph-here}

		\begin{figure-here}
			Top-level example interaction

			\begin{todo}[TECH TODO]
				grab and prep the Fig 5 from proposal
			\end{todo}
		\end{figure-here}

		\begin{paragraph-here}
			As our example, let’s consider the interactions in Figure 5. The key point here is that the variable ”a” is defined after it is used within the function ”k”. To implement this repl, the VM will keep a dedicated linklet instance that we will refer to as the top-level instance. Recall that a linklet instance is (for our example here) a set of linklet variables. In our study we assume that it is implemented as a finite mapping of identifiers to linklet variables. Initially the top-level instance will be an empty instance.
		\end{paragraph-here}

		\begin{figure-here}
			Toplevel example internals at each step.

			\begin{todo}[TECH TODO]
				Create a 1 page big figure for steps in the top-level examples from the proposal document.
			\end{todo}
		\end{figure-here}

		\begin{paragraph-here}
			The key point is the interaction between the language and the run-time through the expander linklet. At each step in the repl, the VM gets a Racket expression to evaluate. Then it applies the read and expand functions imported from the expander linklet, on the given expression. For clarity, we will omit the non-essential details and focus only on the simplified run-time linklet for the expression. Let’s see what happens at each interaction:
		\end{paragraph-here}



		\begin{paragraph-here}
			The important point about the top-level part in this example is the handling of the undefined identifier ”a”. When the expander generates a linklet containing an unidentified identifier, it puts the identifier among the exported variables of the linklet (despite having no corresponding definition for it), allowing it to be handled via the linklet variables. During the compilation of the linklet on the VM, a new linklet variable is created for it with the special value un-initialized, and when the binding for the identifier is needed, it will be dynamically provided using the target instance (in this case using the top-level instance), essentially forming a low-level dynamic scope. Note that we have the variable mappings for both ”a” and the ”k” within the target instance after the instantiation, containing the values un-initialized and a closure with no arguments and body with a reference to vara respectively.
		\end{paragraph-here}


		\begin{paragraph-here}
			Note that the compile-linklet inserted the variable-set! expression in the body to set the value of the variable bound by the external name ”a”. During the instantiation, this variable exists in two possible ways. When the exported variables are processed at the start of the instantiation, if the target instance doesn’t have a variable mapping for ”a”, then a new variable will be created with the uninitialized value (as in the previous step), otherwise if the target does have a mapping for ”a” (which it does in this case), then the target’s variable will be used during the instantiation, and will be set by variable-set!. Note that because of this the binding for a1 in the environment above is set to be the vara (instead of a new variable), since the target does has a mapping for ”a”.
			When instantiating the compiled linklet, because of the first step, the value for the variable vark is resolved as a closure with no arguments and containing a reference to vara in the body. Similarly when that closure is applied, the value for the vara is resolved as 10, thanks to the second step.
		\end{paragraph-here}


		\subsection{Operational Semantics of Linklets}

			\begin{mainpoint}
				Linklets have well-defined operational semantics.

				This is one of the technical contributions of the thesis.
			\end{mainpoint}

			\begin{paragraph-here}
				Now let's introduce formalism for operational semantics of linklets. Figure .... shows the grammar for a linklet language.

				In this section I present a formalism to briefly describe the operational semantics of linklets, which is the basis of the implementation on Pycket. The formalism is developed in the PLT Redex language, therefore it is executable [25]. Randomized testing is used to verify the model [35], and a parallel test suite is used to verify the Pycket implementation and the model with each other
			\end{paragraph-here}


			\begin{paragraph-here}
				Figure \ref{fig:linklet-source} shows the grammar of the linklet
				language, which is a minimal subset of the Fully Expanded Racket
				Programs extended with the \verb|linklet| form and toplevel
				definitions. The sub-language that is used within the linklet body,
				namely the Racket Core (RC) is basically a $\lambda$-calculus with a handful
				of syntactic extensions. In addition to the basic forms such
				as \racketcode{begin}, \racketcode{set!}, \racketcode{if} etc., RC has
				some additional forms to manipulate linklet variables
				(e.g. \emph{var-ref}), as shown in \verb|e| rule. % figure \ref{f
			\end{paragraph-here}

			\begin{paragraph-here}
				Before a linklet is ready for instantiation, as part of the
				\racketcode{compile-linklet} process, several passes over the linklet are
				performed to ensure a correct information flow between the variables
				in the run\dash time. For each import and export identifier (and
				possibly their corresponding renamings), \emph{Import} and
				\emph{Export} objects are created with the fresh references that
				will be used to name the variables that are dynamically created during
				the instantiation. Additionally, a pass on the linklet body collects
				all the identifiers that are defined within the linklet body and all
				the mutated identifiers.
			\end{paragraph-here}



			\begin{paragraph-here}
				Given a set of \emph{Import}s ($\mathit{C_I}$) and a set of
				\emph{Export}s ($\mathit{C_E}$), a set of toplevel defined
				identifiers ($\mathit{X_T}$) and a set of mutated identifiers
				($\mathit{X_M}$), the compilation starts to process each expression in
				the linklet body one by one, performing the following actions
				depending on the type of expression:

			\end{paragraph-here}

			\begin{itemize}
			\small
			\item For a `(\textbf{define-values} (x) e)` expression where $(\textbf{Export}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_E}$ (i.e. x is exported), add an additional `(\textbf{var-set!} $x_{gen}$ x)` expression.
			\item For a `(\textbf{set!} x e)` expression where $(\textbf{Export}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_E}$ (i.e. x is exported), turn the expression into \\ `(\textbf{var-set/check-undef!} $x_{gen}$ e)`.
			\item For any identifier x where $(\textbf{Import}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_I}$  (i.e. x is imported), turn the identifier into \\ `(\textbf{var-ref/no-check} $x_{gen}$)`.
			\item For any identifier x where $(\textbf{Export}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_E}$ and either $x \in \mathit{X_M}$ or $x \notin \mathit{X_T}$, turn the identifier into \\ `(\textbf{var-ref} $x_{gen}$)`.
			\item For any other expression e, recurse if e has subforms, return otherwise.
			\end{itemize}

			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Linklet runtime language
				\end{todo}

				% \begin{wrapfigure}[14]{r}{0.45\textwidth}
				% \vspace{-0.6cm}
				% \footnotesize
				% %\small
				% %\begin{figure}[h!]
				% \begin{mdframed}
				% 	\begin{align*}
				% 	CL             &::=\; \bm{\Phi^C}(L)\\
				% 	L\dash obj     &::= (\la\; c\dash imps \; c\dash exps \; l\dash top \ldots)\\
				% 	\;           &\;|\; (\lb\; x\; l\dash top\; \ldots) \\
				% 	LI             &::=\; (\textbf{linklet\dash instance}\; (x\; var)\; \ldots) \\
				% 	c\dash imps    &::=\; ((imp\dash obj\; \ldots)\; \ldots)\\
				% 	c\dash exps    &::=\; (exp\dash obj\; \ldots)\\
				% 	imp\dash obj   &::=\; (\textbf{Import}\; x\; x\; x) \tag*{[id int ext]} \\
				% 	exp\dash obj   &::=\; (\textbf{Export}\; x\; x\; x) \tag*{[id int ext]} \\
				% 	\end{align*}
				% 	\hfill \footnotesize $\Phi^C : \textbf{compile\dash linklet}$
				% 	\caption[aaa]{Linklet Runtime Language \footref{fnlabel}}
				% 	\label{fig:linklet-runtime}
				% \end{mdframed}
				% %\end{figure}
				% \end{wrapfigure}

			\end{figure-here}


			\begin{paragraph-here}
				Figure \ref{fig:linklet-runtime} shows the grammar of the run\dash
				time language for linklets, i.e. expressions that represent the
				run\dash time objects used during an instantiation of linklets. Given a
				linklet L, \emph{compile-linklet} produces a linklet object $\la$ that
				is ready to be instantiated. $\la$ consists of \emph{Import} and
				\emph{Export} objects for the identifiers denoting the imported and
				exported variables, and the body expressions with potentially some
				additional expressions for variable manipulations in the run\dash
				time.
			\end{paragraph-here}


			\begin{paragraph-here}
				Each \emph{Import} and \emph{Export} object consists of two
				identifiers that are internal and external with respect to the linklet
				body (to accommodate renamings), and one fresh identifier for internal
				use during the instantiation. The \emph{Import} and \emph{Export}
				objects are processed as the first step of the instantiation. As we
				detail below, references for the imported variables are collected from
				the given import instances, and additional variables may be created
				for exported variables depending on the target instance as we have
				shown in the example in \secref{subsec:toplevel-example}. $\lb$
				denotes a compiled linklet object after such a preparation step, with
				which the actual instantition may begin. Note that $\lb$ contains only
				a reference (to the target instance that is used during the
				instantiation) and the body expressions, and doesn't contain the
				import and export objects, as the instantiation uses the variables
				that are already prepared for them. Finally
				a \emph{linklet-instance} is a finite mapping from symbols to
				variables.
			\end{paragraph-here}

			\begin{paragraph-here}
				Since the linklets are lambda\dash like binding forms and not capable
				of starting a computation by themselves, we introduce a top\dash level
				form, namely \racketcode{program}. A \racketcode{program} consists of
				a set of given linklets to be loaded and a single top\dash level
				expression to perform a computation. \figref{fig:linklet-program}
				shows part of the grammar for \racketcode{program}s. We provided
				the \racketcode{let-inst} form to name a linklet instance,
				and \racketcode{seq} form to perform multiple computations in
				sequence.
			\end{paragraph-here}

			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Linklet program source language
				\end{todo}

				% \begin{wrapfigure}[13]{r}{0.5\textwidth}
				% \footnotesize
				% \vspace{-0.5cm}
				% %\begin{figure}[h]
				% \begin{mdframed}
				% 	\begin{align*}
				% 	p           &::=\; (\textbf{program}\; ((x\; L)\; \ldots)\; p\dash top) \\
				% 	p\dash top  &::=\; v\; |\; (\textbf{let\dash inst}\; x\; p\dash top\;p\dash top) \\
				% 	\;          &\;|\; (\textbf{seq}\; p\dash top\; \ldots) \\
				% 	\;          &\;|\; \bm{\Phi^I}(l\dash ref\; x\; \ldots)\; |\; \bm{\Phi^I}(l\dash ref\; x\; \ldots\; \textbf{\#:t}\; x) \\
				% 	\;          &\;|\; \bm{\Phi^V}(x\; x) \\
				% 	l\dash ref &::=\; x\; |\; L\dash obj \\
				% 	v           &::=\; ....\;|\;(v\;x) \\
				% 	\end{align*}
				% 	\hfill \footnotesize $\Phi^V : \textbf{instance\dash variable\dash value}\:,\: \Phi^I : \textbf{instantiate\dash linklet}$
				% 	\caption[bbbb]{Linklet Program Source Language \footnotemark}
				% 	\label{fig:linklet-program}
				% \end{mdframed}
				% %\end{figure}
				% \end{wrapfigure}

			\end{figure-here}


			\begin{paragraph-here}
				As an example, we can represent the top-level repl example from the
				previous section as a linklet \emph{program}, and simulate the
				process. The (multi-step) reduction below demonstrate the compilation of each
				linklet, representing the linklets produced by the expander at each
				repl interaction. After the compilation, the linklets are substitiuted
				in the body and the evaluation starts with reducing the
				body. \figref{fig:reduction} shows the reduction relation, $\beta_p$, that
				implements the evaluation, together with the reduction relation for
				RC, $\beta_r$. For clarity, the reduction of the programs and the linklet
				instantiation is defined together by the same relation ($\beta_p$) so that
				the whole evaluation generating a single small-step sequence of
				reductions from programs to values.
			\end{paragraph-here}


			\begin{paragraph-here}
				After the compilation and loading phase, all the linklet objects are
				in $\la$ form and ready to be instantiated. Recall that a linklet
				instantiation has two modes; \textbf{i)} regular instantiation, where
				a new instance is being created and returned, and \textbf{ii)}
				targeted instantiation, where the given target instance is used during
				the instantiation. Since the only difference between the two modes is
				the return value, for simplicity in the model we remove the
				distinction by turning the regular instantiation into a targeted
				instantiation with a fresh empty instance. The result of both the
				instantiation is then a pair of the last expression's value and the
				target instance being used.
			\end{paragraph-here}

			\begin{paragraph-here}
				At the start of instantiation, the imported variables are collected
				from the given linklet instances by simply going through each set of
				\emph{Import} objects in the $\la$ and the corresponding linklet
				instance that provides the variables. The collected variable
				references are then put into the environment with the names in the
				corresponding \emph{Import} objects that were generated for the
				variables during the compilation. Recall that a linklet may export a
				variable despite having no corresponding definition for it. This is
				achieved by for each \emph{Export} object in $\la$ grabbing the
				variable from the target instance if it has a mapping for it and
				making it available in the environment. Otherwise a fresh variable is
				created and its mapping is placed into the environment and into the
				target instance as well.
			\end{paragraph-here}

			\begin{paragraph-here}
				After processing the import and export variables, the $\la$ object is
				reduced into $\lb$, which triggers the evaluation of the expressions
				in the linklet body. The linklet compilation makes sure that every
				variable reference within the body uses the appropriate variable, and
				at the beginning of the instantiation the preparation of the import
				and export variables explained above provides the actual variables in
				the environment to be modified and used. The reduction then proceeds
				with the evaluation of the body expressions one-by-one. After all the
				expressions are processed, a pair of the last expression's value and
				the reference to the target instance is returned. The reduction of the
				program continues by similarly instantiating the other two linklets
				and finally returning the last value in the
				\verb|seq| form.
			\end{paragraph-here}

			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Step by step toplevel example
				\end{todo}

				% \begin{adjustbox}{center}
				% %\begin{table}[h!]
				% %\vspace{-0.3cm}
				% %\centering
				% %\scriptsize
				% \footnotesize
				% \begin{tabular}{lc|c|c}
				% 	&\textbf{program} & \textbf{$\rho$} & \textbf{$\sigma$} \\ \hline \hline
				% 	&\begin{lstlisting}[mathescape]
				% (program ([l1 (linklet () (a k) (define-values (k) (lambda () a)) (void))]
				% 		[l2 (linklet () (a) (define-values (a) 10) (void))]
				% 		[l3 (linklet () (k) (k))])
				% (let-inst t (make-instance)
				% 	(seq ($\phi^I$ l1 #:t t) ($\phi^I$ l2 #:t t) ($\phi^I$ l3 #:t t))))
				% 	\end{lstlisting} & [] & [] \\ \hline
				% 	$\longrightarrow_{\beta p}*$&\begin{lstlisting}[mathescape]
				% (program ()
				% (let-inst t (make-instance)
				% 	(seq ($\phi^I$ (L$\alpha$ () ((Export a1 a a) (Export k1 k k))
				% 				(define-values (k) (lambda () (var-ref a1)))
				% 				(var-set! k1 k) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export a1 a a))
				% 				(define-values (a) 10) (var-set! a1 a) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export k1 k k)) ((var-ref k1))) #:t t))))
				% 	\end{lstlisting} & [] & [] \\ \hline
				% 	$\longrightarrow_{\beta p}*$&\begin{lstlisting}[mathescape]
				% (program ()
				% (seq ($\phi^I$ (L$\beta$ t (define-values (k) (lambda () (var-ref a1))) (var-set! k1 k) (void)))
				% 		($\phi^I$ (L$\alpha$ () ((Export a1 a a))
				% 				(define-values (a) 10) (var-set! a1 a) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export k1 k k)) ((var-ref k1))) #:t t))))
				% 	\end{lstlisting} & \thead{[k1 $\rightarrow$ $var_k$, \\a1 $\rightarrow$ $var_a$]} & \thead{[$var_a,var_k$ $\rightarrow$ uninit,\\ t $\rightarrow$ (linklet-instance \\ (a $var_a$) (k $var_k$)), \\li $\rightarrow$ (linklet-instance)]} \\ \hline
				% 	$\longrightarrow_{\beta p}*$&\begin{lstlisting}[mathescape]
				% (program ()
				% (seq ($\phi^I$ (L$\beta$ t (var-set! k1 k) (void)))
				% 		($\phi^I$ (L$\alpha$ () ((Export a1 a a))
				% 				(define-values (a) 10) (var-set! a1 a) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export k1 k k)) ((var-ref k1))) #:t t))))
				% 	\end{lstlisting} & \thead{[k $\rightarrow$ $cell_1$,\\k1 $\rightarrow$ $var_k$,\\a1 $\rightarrow$ $var_a$]} & \thead{[$cell_1$ $\rightarrow$ closure,\\$var_a,var_k$ $\rightarrow$ uninit,\\t $\rightarrow$ (linklet-instance\\(a $var_a$) (k $var_k$)),\\li $\rightarrow$ (linklet-instance)]} \\ \hline
				% \end{tabular}
				% %\end{table}
				% \end{adjustbox}

			\end{figure-here}


			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Linklets reduction relation
				\end{todo}

				% \begin{figure}[h!]
				% \footnotesize
				% \begin{mdframed}
				% 	\begin{align*}
				% 	\rcinput{x} \rcrel \rcoutput{\sigma[\rho[x]]}{\rho}{\sigma} \\
				% 	\rcinput{(\textbf{var\dash ref}\; x))} \rcrel \rcoutput{v}{\rho}{\sigma}\; \where x \in \rho, \rho[x] \in \sigma, v = \sigma[\rho[x]], v \neq uninit\\
				% 	\rcinput{(\textbf{var\dash ref/no\dash check}\; x))} \rcrel \rcoutput{v}{\rho}{\sigma}\; \where v = \sigma[\rho[x]] \\
				% 	\rcinput{(\textbf{var\dash set!}\; x\; v)} \rcrel \rcoutput{(void)}{\rho}{\sigma_1} \where \sigma_1 = \sigma[\rho[x]\rightarrow v]\\
				% 	\rcinput{(\textbf{var\dash set/check\dash undef!}\; x\; v)} \rcrel \rcoutput{(void)}{\rho}{\sigma_1} \where \sigma_1 = \sigma[\rho[x]\rightarrow v], x \in \rho\\
				% 	\rcinput{(\textbf{set!}\; x\; v)} \rcrel \rcoutput{(void)}{\rho}{\sigma_1} \where \sigma_1 = \sigma[\rho[x]\rightarrow v]\\
				% 	\\
				% 	\redinput{\bm{\Phi^V}(x_{li},\; x)} \rel \redoutput{v}{\rho}{\sigma} \where v\; =\; \sigma[(\sigma[x_{li}])[x]] \\
				% 	%% \redinput{(\textbf{let\dash inst}\; x\; (v\;x_i)\; p\dash top)} \rel \redoutput{p\dash top}{\rho}{\sigma_1} \where \sigma_1 = \sigma[x\rightarrow \sigma[x_i]] \\
				% 	%% \redinput{(\textbf{seq}\; v_{1}\; \ldots\; v_{n})} \rel \redoutput{v_{n}}{\rho}{\sigma} \\
				% 	\redinput{(\bm{\Phi^I}\; (\lb\; x\; v\; \ldots\; v_{l}))} \rel \redoutput{(v_{l}\; x)}{\rho}{\sigma} \\
				% 	EP\;\llbracket (\bm{\Phi^I}(\lb\; x_{t}\; v_p\; \ldots\; (\textbf{define\dash values}\; (x)\; v)\; l\dash top\; \ldots)) \rrbracket, \rel \redoutput{\bm{\Phi^I}(\lb\; x_{t}\; v_p\; \ldots\; l\dash top\; \ldots)}{\rho_1}{\sigma_1} \\
				% 	\;          &\;\; \where \rho_1 = \rho[x\rightarrow cell],\; \sigma_1 = \sigma[cell\rightarrow v] \\
				% 	\redinput{(\bm{\Phi^I}(\la\; c\dash imps \; c\dash exps \; l\dash top \ldots)\; LI\; \ldots)} \rel \redoutput{(\bm{\Phi^I}(\la\; c\dash imps \; c\dash exps \; l\dash top\; \ldots)\; LI\; \ldots\; \textbf{\#:t}\; x_{t})}{\rho}{\sigma_1} \\
				% 	\;          &\;\; \where x_t \notin \mathit{dom}(\sigma), \sigma_1 = \sigma[x_t\rightarrow (linklet\dash instance)] \\
				% 	EP\;\llbracket (\bm{\Phi^I}(\la\; c\dash imps \; c\dash exps \; l\dash top \ldots)\; LI\; \ldots\; \textbf{\#:t}\; x_{t}) \rrbracket, \rho, \sigma\; \rel \redoutput{(\bm{\Phi^I}(\lb\; x_{t}\; l\dash top\; \ldots))}{\rho_2}{\sigma_1} \\
				% 	\; &\;\; \where \rho_1 = \mathit{V}^I(c\dash imps, (LI\; \ldots), \rho) \\
				% 	\;          &\;\; \hspace{0.4cm} (\rho_2, \sigma_1) = \mathit{V}^E(c\dash exps, x_t, \rho_1, \sigma) \\
				% 	(\textbf{program}\; ((x\;L),(x_1\;L_1)\;\ldots)\;p\dash top), \rho, \sigma &\longrightarrow_{\beta p}\; (\textbf{program}\; ((x_1\;L_1)\;\ldots)\;p\dash top[x := \bm{\Phi^C}(L)]), \rho, \sigma \\ \\
				% 	eval^{\longrightarrow_{\beta p}}(p) &=\; v\; \textbf{if}\; p, (), () \twoheadrightarrow_{\beta p\cup\beta r} \; (\textbf{program}\; ()\;(v\;\_)) \\ \\
				% 	%% \mathit{V}^I : c\dash imps \times (LI\;\ldots) \times \rho &\longrightarrow \rho \\
				% 	%% \mathit{V}^I((\overline{(\overline{(\textbf{Import}\; x_{id}\;x_{int}\;x_{ext})})_n}), (\overline{LI_n}), \rho) &= \rho\overline{[x_{id}\rightarrow LI_n[x_{ext}]]}\\ \\
				% 	%% \mathit{V}^E : c\dash exps \times x \times \rho \times \sigma &\longrightarrow \rho \times \sigma \\
				% 	%% \mathit{V}^E((exp\dash obj\;\ldots), x_t, \rho, \sigma) &= \mathit{P}(exp\dash obj, x_t, \sigma[x_t], \rho, \sigma)\;\ldots\\
				% 	%% \mathit{P}((\textbf{Export}\;x_{id}\;x_{int}\;x_{ext}), x_t, LI_t, \rho, \sigma) &= \begin{cases*}
				% 	%%   \rho_1, \sigma & if $\;x_{ext} \in dom(LI_t)$, \where $\rho_1 = \rho[x_{id}\rightarrow LI_t[x_{ext}]]$ \\
				% 	%%   \rho_1, \sigma_1 & if $\;x_{ext} \notin dom(LI_t)$, \where $\rho_1 = \rho[x_{id}\rightarrow var_{new}]$\\
				% 	%%   \;        &\; \hspace{2.6cm} $var_{new} \notin \sigma$ \\
				% 	%%   \;        &\; \hspace{2.6cm} $\sigma_1 = \sigma[var_{new}\rightarrow uninit,$ \\
				% 	%%     \;        &\; \hspace{3.2cm} $x_t\rightarrow LI_t[x_{ext}\rightarrow var_{new}]]$
				% 	%% \end{cases*} \\
				% 	\end{align*}
				% 	\centering
				% 	\footnotesize $\Phi^V : \textbf{instance\dash variable\dash value}\:,\: \Phi^I : \textbf{instantiate\dash linklet},\:\Phi^C : \textbf{compile\dash linklet}$

				% 	\footnotesize $\mathit{V}^I : \textbf{get  import variables},\: \mathit{V}^E : \textbf{create variables for exports}$
				% 	\caption[ccc]{Reduction Relation \footnotemark}
				% 	\label{fig:reduction}
				% \end{mdframed}
				% \end{figure}

			\end{figure-here}

			\begin{paragraph-here}
				These are all implemented in a PLT Redex model, codes are all in the appendix

				maybe give a GitHub link as well?
			\end{paragraph-here}



	\refstepcounter{section}          % advance the counter
	\section*{\thesection\quad Conclusion}

		\begin{paragraph-here}
			The ability to provide high-level functionalities to runtime is one of the key ideas in improving portability.


			The ability to provide high-level functionalities as callable functions to the hosting virtual machine is one of the key ideas in improving Racket’s portability. A VM that wants to host Racket not only gets the high-level implementations such as the module system, macro system for free, but also gets highly re-usable functionalities that it can integrate the systems it implements, such as the top-level repl example in Figure 16.
		\end{paragraph-here}

		\begin{paragraph-here}
			Interplay between the language and the runtime is cool.


			Moreover, Racket implements and exports abstract functionalities that are tightly coupled with the hosting runtime as well. For instance the expander linklet provides the eval function, which is basically an abstract interpreter for Racket. A VM that hosts Racket can call eval, which interprets Racket code by using the run-time primitives and compile-linklet and instantiate-linklet that are implemented and provided by the VM itself. Therefore, one of the essential nuances of self-hosting Racket with the expander linklet, is that the interaction between the run-time and the expander is a two-way street. The VM implements and uses compile-linklet and instantiate-linklet to import the functions provided by the expander, and the expander provides functions that uses the compile-linklet and instantiate-linklet functions, along with the other run-time primitives as well.
		\end{paragraph-here}

		\begin{paragraph-here}
			Interplay between the language and the runtime is cool. Merge with the previous paragraph.

			For example, the dynamic-require used above (provided by the expander linklet) is a Racket function that dynamically loads a Racket module (if it’s not already loaded) by resolving the module path, finding the source code in the file system, reading and expanding the codes and modifying the namespace registry. The Racket code inside the expander that implements all that, calls run-time primitives such as for file-system support and also calls the compile-linklet and instantiate-linklet for expanding and instantiating all the required modules. eval works in a similar fashion as well. This intertwined nature of the high-level language facilities and the low-level run-time support is central to the Racket’s improved portability.
		\end{paragraph-here}



	% This is a figure in landscape orientation
	% \begin{sidewaysfigure}
	% 		\includegraphics[width=\textwidth]{\figPath{pl-portability}/exampleFigure.png}
	% \caption{This is another example Figure, rotated to landscape orientation.}
	% \label{LandscapeFigure}
	% \end{sidewaysfigure}
