\chapter[\texorpdfstring{PROGRAMMING LANGUAGES \& PORTABILITY}
                          {Linklets}]{PROGRAMMING LANGUAGES \& PORTABILITY}
\label{chapter:linklets}

	\begin{chaptersynopsis}

        Making programming languages more portable is good, and here's a way to do that.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Enriching Compiler \& Runtime Communication

                Motivation for linklets. Making programming languages more portable is good.
			\item Linklets as Units of Compilation

                Semantics for linklets. Linklets are good tools to improve communication between the compiler and runtime.
		\end{itemize}
    \end{chaptersynopsis}

	\begin{paragraph-here}
		The general anatomy of a practical, real programming language, has:

			- a language grammar: expressions you can form in that language -- stuff you can express -- the syntax

			- core language semantics: what you mean by what you express -- reduction semantics -- rules that takes you from an expression to a value

			- runtime: the machinery that allows you to realize the reduction semantics on a computing environment. You need to be able to read and expand expressions (allow users to make expressions in the language), print values (allow users to evaluate expressions and receive values).
	\end{paragraph-here}

	\begin{paragraph-here}
		Portability of a programming language is the ability to re-target different runtimes... Some languages suck at it, some languages are good at re-targeting different VMs...

		I'm not talking about languages having multiple different runtimes. I'm talking about a support at the language syntax or semantic level that allows runtimes to easily adopt and implement the language on itself.

		\begin{todo}[TECH TODO]
			example languages?
		\end{todo}
	\end{paragraph-here}

	\paragraph{}%
		Other languages whose own syntax / semantics deliberately expose an intermediate form that can be “plugged” into new back‑ends include \textbf{Haskell} (the \gls{ghc} toolchain lowers every module to the typed Core → STG IR; adding the 2010 LLVM back‑end immediately let all existing Haskell code run on any CPU for which LLVM can spit machine code \cite{ghc_llvm_backend}), \textbf{Nim} (its self‑hosting compiler first rewrites Nim to a backend‑neutral tree and then mechanically emits C, C++, Objective‑C, or JavaScript—so porting Nim itself to a fresh architecture usually needs only a functioning C toolchain \cite{nim_porting}), and \textbf{Common Lisp} (implementations such as Clasp keep the macroexpander, reader and most of the runtime written \emph{in} Lisp while swapping only the final code generator—LLVM, JVM byte‑code, or C—thus retargeting the whole language by replacing a single layer \cite{clasp_llvm}).  Like Racket’s linklets, these designs localise platform knowledge in a thin backend, leaving almost all compiler and library code intact when a new platform arrives.


	\begin{paragraph-here}
		More portability is good because

		\begin{todo}[TECH TODO]
			find motivation for portability
		\end{todo}
	\end{paragraph-here}

	\begin{paragraph-here}
		Another good thing about improved portability is ....

		\begin{todo}[TECH TODO]
			find motivation for portability
		\end{todo}
	\end{paragraph-here}

	\begin{paragraph-here}
		Improving portability of a language requires improving the semantic communication between the language's core semantics and its runtime.
	\end{paragraph-here}

	\begin{paragraph-here}
		 In this chapter, we'll first study as an example how Racket achieved improved portability, and then introduce the key construct (linklet) that allows it to self-host on its runtime, which is exactly what allows us to self-host it on Pycket to prove our thesis.
	\end{paragraph-here}

% This is not only about Racket, the CPython is written in C. Python developers don't want to write C, they
	% want to write Python....

	% ICFP'19 experience report

	\section[\texorpdfstring{Enriching Compiler \& Runtime Communication}{Motivation for Linklets}]{Enriching Compiler \& Runtime Communication}

		\begin{mainpoint}
			Motivation for linklets.

			Making programming languages more portable is good.

			It requires improving communication between the compiler and runtime.
		\end{mainpoint}

		\begin{paragraph-here}
			There's a tight coupling between the runtime and the reduction semantics in a programming language.

				- You may have a certain way to read the source of your language, but if you have a language with a macro system and a macro expansion phase, then that way of reading might change, in which case you might need a new regexp implementation as well.

				- You may have a certain way to serialize values/objects of your language into the file system to un-marshall it later back into the memory. Runtime needs to know how.

				- Your language may provide its own semantics for green (user level) threads, so runtime has to know how to map them to OS threads.
		\end{paragraph-here}

		\begin{paragraph-here}
			Without any assistance from the language, every runtime that wants to implement the language needs to hand-roll all of these couplings between the core language and the runtime.
		\end{paragraph-here}

		\begin{paragraph-here}
			 If there was a communication form/protocol/IR that allows a language to essentially teach a runtime how to realize these tight couplings, then any runtime that wants to implement the language needs only to implement that form/protocol/IR and receive all these functionalities from the language itself.
		\end{paragraph-here}

		\begin{paragraph-here}
			One good example for a language that improved its portability this way is Racket, which became more portable as an effort to target Chez Scheme as its primary runtime in 2019. This portability allows us to self-host Racket on Pycket for our thesis.
		\end{paragraph-here}

		\inputFigure{linklets}{racket-on-chez-3-stacks-figure}

		\begin{paragraph-here}
			Racket turned everything on the stack from C to Racket, notably the expander, which implements macro system, module system, read, expand, basically most of the high-level stuff you need for reading and expanding Racket code in any language that Racket macro expander can elaborate. \figref{fig:racket-on-chez}
		\end{paragraph-here}

		\inputFigure{linklets}{racket-expand-example-figure}

		\begin{paragraph-here}
			The Racket macro expander is also made to elaborate given Racket code into a core IR-like language for the hosting compiler, the runtime to consume. As we will discuss in more detail in the next section, the essential forms of this language, acting as units of compilation in the run-time, are called the "linklets". This is the key move to improve portability and also make self-hosting possible. \figref{fig:racket-expand-example}
		\end{paragraph-here}

		\begin{paragraph-here}
			How? Because now, everything a runtime that wants to implement Racket needs to do is to implement how to compile and run serialized linklets that are given by the language, basically to understand this internal language. Once it does that, then Racket as a language applies offline the expander to its facilities to export functionality in the form of linklets, such as IO, threads, etc. Importantly, it also applies the expander to itself to export the Racket macro expander as a single independent linklet, so once compiling and loading it, the runtime has the entire module system, macro system, reader, expander, etc., ready to use in its memory, without writing a single line of high-level code about these systems that are strictly about Racket language in high-level. This allows runtime to grab, read and expand any given Racket code into a core Racket language that runtime already understands and knows how to evaluate. In other words, this is what enables a runtime to self-host Racket.
		\end{paragraph-here}


	\section[\texorpdfstring{Linklets as Units of Compilation}{Semantics for Linklets}]{Linklets as Units of Compilation}
		\label{section:linklet-semantics}

		\begin{mainpoint}
			Semantics for linklets.

			Linklets are good tools to improve communication between the compiler and runtime.
		\end{mainpoint}

		\begin{paragraph-here}
			In this section, we introduce linklets as a language form and provide formal operational semantics, the minimal API for a VM to implement to support linklets, along with a practical example of how they implement an interesting functionality.
		\end{paragraph-here}

		\inputFigure{linklets}{linklet-source-language-figure}

		\begin{paragraph-here}
			A \emph{linklet}, as a language form, is a lambda-like binding form that consists of four main components, as can be seen in \figref{fig:linklet-grammar}:

			\begin{itemize}
				\item A set of imported variables.
				\item A set of exported variables.
				\item A body that consists of variable definitions and expressions.
			\end{itemize}

			Some real-life s-expressions for linklets can be seen in \figref{fig:racket-expand-example}. The set of imported variables brings in variables from other linklets, while the exported make variables available to other linklets. One of the key things that allows linklets to do interesting things is that the set of exported variables can have some variables that have no corresponding definitions in the body. [<-- cliffhanger for next paragraph]
		\end{paragraph-here}

		\begin{paragraph-here}
			Linklets as s-expressions by themselves are as much interesting as an s-expression for a \racketcode{lambda} form. But when \emph{compiled} by a hosting runtime into a linklet object, a linklet becomes ready for \emph{instantiation}. Instantiating a linklet is essentially very similar to a function application with some extra bookkeeping regarding the imported and exported variables, eventually running the expressions within the body.


			The purpose of a linklet instantiation is to produce a \emph{linklet instance}, which is a mapping of variables to values, plus some additional data.

			What do you do with it? Basic instantiation semantics.. figure 3 from quals.
		\end{paragraph-here}

		To run a linklet, it is instantiated as a linklet instance, which is a container for a set of linklet variables and some other data (e.g. namespace). When a linklet is instantiated, it receives other linklet instances for its imports, and it extracts a specified set of variables that are exported from each of the given instances. The newly created linklet instance provides its exported variables for use by other linklets. Moreover, an instantiation may be given an additional linklet instance as an input, namely the target instance. In this case, the variables in the target instance is used and modified for the linklet definitions and expressions during the evaluation of the body expressions, and the result is the value of the last expression in the linklet (instead of an instance). In the remainder of this document we will use the names “targeted instantiation” and “regular instantiation” for these two modes. \figref{fig:basic-linklet-instantiation}


		\inputFigure{linklets}{basic-linklet-instantiation-figure}



		\subsection{Operational Example: A Small Top-level REPL Interaction}

		\begin{paragraph-here}
			Before we jump in to the operational semantics, let's go over an example to see how they work internally to implement a top-level repl.

			Let’s take a look at how a VM that implements linklets can easily implement functionalities such as the Racket top-level repl3 by loading the expander linklet into its run-time. Note that the top-level itself is quite complicated and beyond the scope of our study. The example here aims to provide a general overview of the interaction between the run-time and the functionalities provided by the language through the linklets, for this exercise in particular the expander linklet. Recall that the expander implements functions such as read, expand, eval, and outputs a bundle of linklets for a given Racket code. Let’s first briefly describe what linklets are and how linklets operate. In Section 3.2.2 I will provide linklets’ operational semantics with a formalism in more detail.
		\end{paragraph-here}


		\begin{paragraph-here}
			The minimal API for a virtual machine to implement the linklets consists of the functions i) compile-linklet for preparing a linklet for instantiation and ii) instantiate-linklet for running a compiled linklet. In particular, the VM uses the compile-linklet to take an s-expression for a linklet as input and produce a linklet object in a representation of its choice, containing the run-time AST for the codes inside the linklet. Therefore, loading a linklet into its run-time for a VM means that the functions provided by the linklet are callable during the run-time. For example after loading the expander linklet, a VM can call the functions from Racket’s expander such as read, expand, eval to use Racket’s module system, macro system etc.
		\end{paragraph-here}

		\begin{figure-here}
			Top-level example interaction

			\begin{todo}[TECH TODO]
				grab and prep the Fig 5 from proposal
			\end{todo}
		\end{figure-here}

		\begin{paragraph-here}
			As our example, let’s consider the interactions in Figure 5. The key point here is that the variable ”a” is defined after it is used within the function ”k”. To implement this repl, the VM will keep a dedicated linklet instance that we will refer to as the top-level instance. Recall that a linklet instance is (for our example here) a set of linklet variables. In our study we assume that it is implemented as a finite mapping of identifiers to linklet variables. Initially the top-level instance will be an empty instance.
		\end{paragraph-here}

		\begin{figure-here}
			Toplevel example internals at each step.

			\begin{todo}[TECH TODO]
				Create a 1 page big figure for steps in the top-level examples from the proposal document.
			\end{todo}
		\end{figure-here}

		\begin{paragraph-here}
			The key point is the interaction between the language and the run-time through the expander linklet. At each step in the repl, the VM gets a Racket expression to evaluate. Then it applies the read and expand functions imported from the expander linklet, on the given expression. For clarity, we will omit the non-essential details and focus only on the simplified run-time linklet for the expression. Let’s see what happens at each interaction:
		\end{paragraph-here}



		\begin{paragraph-here}
			The important point about the top-level part in this example is the handling of the undefined identifier ”a”. When the expander generates a linklet containing an unidentified identifier, it puts the identifier among the exported variables of the linklet (despite having no corresponding definition for it), allowing it to be handled via the linklet variables. During the compilation of the linklet on the VM, a new linklet variable is created for it with the special value un-initialized, and when the binding for the identifier is needed, it will be dynamically provided using the target instance (in this case using the top-level instance), essentially forming a low-level dynamic scope. Note that we have the variable mappings for both ”a” and the ”k” within the target instance after the instantiation, containing the values un-initialized and a closure with no arguments and body with a reference to vara respectively.
		\end{paragraph-here}


		\begin{paragraph-here}
			Note that the compile-linklet inserted the variable-set! expression in the body to set the value of the variable bound by the external name ”a”. During the instantiation, this variable exists in two possible ways. When the exported variables are processed at the start of the instantiation, if the target instance doesn’t have a variable mapping for ”a”, then a new variable will be created with the uninitialized value (as in the previous step), otherwise if the target does have a mapping for ”a” (which it does in this case), then the target’s variable will be used during the instantiation, and will be set by variable-set!. Note that because of this the binding for a1 in the environment above is set to be the vara (instead of a new variable), since the target does has a mapping for ”a”.
			When instantiating the compiled linklet, because of the first step, the value for the variable vark is resolved as a closure with no arguments and containing a reference to vara in the body. Similarly when that closure is applied, the value for the vara is resolved as 10, thanks to the second step.
		\end{paragraph-here}


		\subsection{Operational Semantics of Linklets}

			\begin{mainpoint}
				Linklets have well-defined operational semantics.

				This is one of the technical contributions of the thesis.
			\end{mainpoint}

			\begin{paragraph-here}
				Now let's introduce formalism for operational semantics of linklets. Figure .... shows the grammar for a linklet language.

				In this section I present a formalism to briefly describe the operational semantics of linklets, which is the basis of the implementation on Pycket. The formalism is developed in the PLT Redex language, therefore it is executable [25]. Randomized testing is used to verify the model [35], and a parallel test suite is used to verify the Pycket implementation and the model with each other
			\end{paragraph-here}


			\begin{paragraph-here}
				Figure \ref{fig:linklet-source} shows the grammar of the linklet
				language, which is a minimal subset of the Fully Expanded Racket
				Programs extended with the \verb|linklet| form and toplevel
				definitions. The sub-language that is used within the linklet body,
				namely the Racket Core (RC) is basically a $\lambda$-calculus with a handful
				of syntactic extensions. In addition to the basic forms such
				as \racketcode{begin}, \racketcode{set!}, \racketcode{if} etc., RC has
				some additional forms to manipulate linklet variables
				(e.g. \emph{var-ref}), as shown in \verb|e| rule. % figure \ref{f
			\end{paragraph-here}

			\begin{paragraph-here}
				Before a linklet is ready for instantiation, as part of the
				\racketcode{compile-linklet} process, several passes over the linklet are
				performed to ensure a correct information flow between the variables
				in the run\dash time. For each import and export identifier (and
				possibly their corresponding renamings), \emph{Import} and
				\emph{Export} objects are created with the fresh references that
				will be used to name the variables that are dynamically created during
				the instantiation. Additionally, a pass on the linklet body collects
				all the identifiers that are defined within the linklet body and all
				the mutated identifiers.
			\end{paragraph-here}



			\begin{paragraph-here}
				Given a set of \emph{Import}s ($\mathit{C_I}$) and a set of
				\emph{Export}s ($\mathit{C_E}$), a set of toplevel defined
				identifiers ($\mathit{X_T}$) and a set of mutated identifiers
				($\mathit{X_M}$), the compilation starts to process each expression in
				the linklet body one by one, performing the following actions
				depending on the type of expression:

			\end{paragraph-here}

			\begin{itemize}
			\small
			\item For a `(\textbf{define-values} (x) e)` expression where $(\textbf{Export}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_E}$ (i.e. x is exported), add an additional `(\textbf{var-set!} $x_{gen}$ x)` expression.
			\item For a `(\textbf{set!} x e)` expression where $(\textbf{Export}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_E}$ (i.e. x is exported), turn the expression into \\ `(\textbf{var-set/check-undef!} $x_{gen}$ e)`.
			\item For any identifier x where $(\textbf{Import}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_I}$  (i.e. x is imported), turn the identifier into \\ `(\textbf{var-ref/no-check} $x_{gen}$)`.
			\item For any identifier x where $(\textbf{Export}\; x_{gen}\; x\; x_{ext}) \in \mathit{C_E}$ and either $x \in \mathit{X_M}$ or $x \notin \mathit{X_T}$, turn the identifier into \\ `(\textbf{var-ref} $x_{gen}$)`.
			\item For any other expression e, recurse if e has subforms, return otherwise.
			\end{itemize}

			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Linklet runtime language
				\end{todo}

				% \begin{wrapfigure}[14]{r}{0.45\textwidth}
				% \vspace{-0.6cm}
				% \footnotesize
				% %\small
				% %\begin{figure}[h!]
				% \begin{mdframed}
				% 	\begin{align*}
				% 	CL             &::=\; \bm{\Phi^C}(L)\\
				% 	L\dash obj     &::= (\la\; c\dash imps \; c\dash exps \; l\dash top \ldots)\\
				% 	\;           &\;|\; (\lb\; x\; l\dash top\; \ldots) \\
				% 	LI             &::=\; (\textbf{linklet\dash instance}\; (x\; var)\; \ldots) \\
				% 	c\dash imps    &::=\; ((imp\dash obj\; \ldots)\; \ldots)\\
				% 	c\dash exps    &::=\; (exp\dash obj\; \ldots)\\
				% 	imp\dash obj   &::=\; (\textbf{Import}\; x\; x\; x) \tag*{[id int ext]} \\
				% 	exp\dash obj   &::=\; (\textbf{Export}\; x\; x\; x) \tag*{[id int ext]} \\
				% 	\end{align*}
				% 	\hfill \footnotesize $\Phi^C : \textbf{compile\dash linklet}$
				% 	\caption[aaa]{Linklet Runtime Language \footref{fnlabel}}
				% 	\label{fig:linklet-runtime}
				% \end{mdframed}
				% %\end{figure}
				% \end{wrapfigure}

			\end{figure-here}


			\begin{paragraph-here}
				Figure \ref{fig:linklet-runtime} shows the grammar of the run\dash
				time language for linklets, i.e. expressions that represent the
				run\dash time objects used during an instantiation of linklets. Given a
				linklet L, \emph{compile-linklet} produces a linklet object $\la$ that
				is ready to be instantiated. $\la$ consists of \emph{Import} and
				\emph{Export} objects for the identifiers denoting the imported and
				exported variables, and the body expressions with potentially some
				additional expressions for variable manipulations in the run\dash
				time.
			\end{paragraph-here}


			\begin{paragraph-here}
				Each \emph{Import} and \emph{Export} object consists of two
				identifiers that are internal and external with respect to the linklet
				body (to accommodate renamings), and one fresh identifier for internal
				use during the instantiation. The \emph{Import} and \emph{Export}
				objects are processed as the first step of the instantiation. As we
				detail below, references for the imported variables are collected from
				the given import instances, and additional variables may be created
				for exported variables depending on the target instance as we have
				shown in the example in \secref{subsec:toplevel-example}. $\lb$
				denotes a compiled linklet object after such a preparation step, with
				which the actual instantition may begin. Note that $\lb$ contains only
				a reference (to the target instance that is used during the
				instantiation) and the body expressions, and doesn't contain the
				import and export objects, as the instantiation uses the variables
				that are already prepared for them. Finally
				a \emph{linklet-instance} is a finite mapping from symbols to
				variables.
			\end{paragraph-here}

			\begin{paragraph-here}
				Since the linklets are lambda\dash like binding forms and not capable
				of starting a computation by themselves, we introduce a top\dash level
				form, namely \racketcode{program}. A \racketcode{program} consists of
				a set of given linklets to be loaded and a single top\dash level
				expression to perform a computation. \figref{fig:linklet-program}
				shows part of the grammar for \racketcode{program}s. We provided
				the \racketcode{let-inst} form to name a linklet instance,
				and \racketcode{seq} form to perform multiple computations in
				sequence.
			\end{paragraph-here}

			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Linklet program source language
				\end{todo}

				% \begin{wrapfigure}[13]{r}{0.5\textwidth}
				% \footnotesize
				% \vspace{-0.5cm}
				% %\begin{figure}[h]
				% \begin{mdframed}
				% 	\begin{align*}
				% 	p           &::=\; (\textbf{program}\; ((x\; L)\; \ldots)\; p\dash top) \\
				% 	p\dash top  &::=\; v\; |\; (\textbf{let\dash inst}\; x\; p\dash top\;p\dash top) \\
				% 	\;          &\;|\; (\textbf{seq}\; p\dash top\; \ldots) \\
				% 	\;          &\;|\; \bm{\Phi^I}(l\dash ref\; x\; \ldots)\; |\; \bm{\Phi^I}(l\dash ref\; x\; \ldots\; \textbf{\#:t}\; x) \\
				% 	\;          &\;|\; \bm{\Phi^V}(x\; x) \\
				% 	l\dash ref &::=\; x\; |\; L\dash obj \\
				% 	v           &::=\; ....\;|\;(v\;x) \\
				% 	\end{align*}
				% 	\hfill \footnotesize $\Phi^V : \textbf{instance\dash variable\dash value}\:,\: \Phi^I : \textbf{instantiate\dash linklet}$
				% 	\caption[bbbb]{Linklet Program Source Language \footnotemark}
				% 	\label{fig:linklet-program}
				% \end{mdframed}
				% %\end{figure}
				% \end{wrapfigure}

			\end{figure-here}


			\begin{paragraph-here}
				As an example, we can represent the top-level repl example from the
				previous section as a linklet \emph{program}, and simulate the
				process. The (multi-step) reduction below demonstrate the compilation of each
				linklet, representing the linklets produced by the expander at each
				repl interaction. After the compilation, the linklets are substitiuted
				in the body and the evaluation starts with reducing the
				body. \figref{fig:reduction} shows the reduction relation, $\beta_p$, that
				implements the evaluation, together with the reduction relation for
				RC, $\beta_r$. For clarity, the reduction of the programs and the linklet
				instantiation is defined together by the same relation ($\beta_p$) so that
				the whole evaluation generating a single small-step sequence of
				reductions from programs to values.
			\end{paragraph-here}


			\begin{paragraph-here}
				After the compilation and loading phase, all the linklet objects are
				in $\la$ form and ready to be instantiated. Recall that a linklet
				instantiation has two modes; \textbf{i)} regular instantiation, where
				a new instance is being created and returned, and \textbf{ii)}
				targeted instantiation, where the given target instance is used during
				the instantiation. Since the only difference between the two modes is
				the return value, for simplicity in the model we remove the
				distinction by turning the regular instantiation into a targeted
				instantiation with a fresh empty instance. The result of both the
				instantiation is then a pair of the last expression's value and the
				target instance being used.
			\end{paragraph-here}

			\begin{paragraph-here}
				At the start of instantiation, the imported variables are collected
				from the given linklet instances by simply going through each set of
				\emph{Import} objects in the $\la$ and the corresponding linklet
				instance that provides the variables. The collected variable
				references are then put into the environment with the names in the
				corresponding \emph{Import} objects that were generated for the
				variables during the compilation. Recall that a linklet may export a
				variable despite having no corresponding definition for it. This is
				achieved by for each \emph{Export} object in $\la$ grabbing the
				variable from the target instance if it has a mapping for it and
				making it available in the environment. Otherwise a fresh variable is
				created and its mapping is placed into the environment and into the
				target instance as well.
			\end{paragraph-here}

			\begin{paragraph-here}
				After processing the import and export variables, the $\la$ object is
				reduced into $\lb$, which triggers the evaluation of the expressions
				in the linklet body. The linklet compilation makes sure that every
				variable reference within the body uses the appropriate variable, and
				at the beginning of the instantiation the preparation of the import
				and export variables explained above provides the actual variables in
				the environment to be modified and used. The reduction then proceeds
				with the evaluation of the body expressions one-by-one. After all the
				expressions are processed, a pair of the last expression's value and
				the reference to the target instance is returned. The reduction of the
				program continues by similarly instantiating the other two linklets
				and finally returning the last value in the
				\verb|seq| form.
			\end{paragraph-here}

			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Step by step toplevel example
				\end{todo}

				% \begin{adjustbox}{center}
				% %\begin{table}[h!]
				% %\vspace{-0.3cm}
				% %\centering
				% %\scriptsize
				% \footnotesize
				% \begin{tabular}{lc|c|c}
				% 	&\textbf{program} & \textbf{$\rho$} & \textbf{$\sigma$} \\ \hline \hline
				% 	&\begin{lstlisting}[mathescape]
				% (program ([l1 (linklet () (a k) (define-values (k) (lambda () a)) (void))]
				% 		[l2 (linklet () (a) (define-values (a) 10) (void))]
				% 		[l3 (linklet () (k) (k))])
				% (let-inst t (make-instance)
				% 	(seq ($\phi^I$ l1 #:t t) ($\phi^I$ l2 #:t t) ($\phi^I$ l3 #:t t))))
				% 	\end{lstlisting} & [] & [] \\ \hline
				% 	$\longrightarrow_{\beta p}*$&\begin{lstlisting}[mathescape]
				% (program ()
				% (let-inst t (make-instance)
				% 	(seq ($\phi^I$ (L$\alpha$ () ((Export a1 a a) (Export k1 k k))
				% 				(define-values (k) (lambda () (var-ref a1)))
				% 				(var-set! k1 k) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export a1 a a))
				% 				(define-values (a) 10) (var-set! a1 a) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export k1 k k)) ((var-ref k1))) #:t t))))
				% 	\end{lstlisting} & [] & [] \\ \hline
				% 	$\longrightarrow_{\beta p}*$&\begin{lstlisting}[mathescape]
				% (program ()
				% (seq ($\phi^I$ (L$\beta$ t (define-values (k) (lambda () (var-ref a1))) (var-set! k1 k) (void)))
				% 		($\phi^I$ (L$\alpha$ () ((Export a1 a a))
				% 				(define-values (a) 10) (var-set! a1 a) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export k1 k k)) ((var-ref k1))) #:t t))))
				% 	\end{lstlisting} & \thead{[k1 $\rightarrow$ $var_k$, \\a1 $\rightarrow$ $var_a$]} & \thead{[$var_a,var_k$ $\rightarrow$ uninit,\\ t $\rightarrow$ (linklet-instance \\ (a $var_a$) (k $var_k$)), \\li $\rightarrow$ (linklet-instance)]} \\ \hline
				% 	$\longrightarrow_{\beta p}*$&\begin{lstlisting}[mathescape]
				% (program ()
				% (seq ($\phi^I$ (L$\beta$ t (var-set! k1 k) (void)))
				% 		($\phi^I$ (L$\alpha$ () ((Export a1 a a))
				% 				(define-values (a) 10) (var-set! a1 a) (void)) #:t t)
				% 		($\phi^I$ (L$\alpha$ () ((Export k1 k k)) ((var-ref k1))) #:t t))))
				% 	\end{lstlisting} & \thead{[k $\rightarrow$ $cell_1$,\\k1 $\rightarrow$ $var_k$,\\a1 $\rightarrow$ $var_a$]} & \thead{[$cell_1$ $\rightarrow$ closure,\\$var_a,var_k$ $\rightarrow$ uninit,\\t $\rightarrow$ (linklet-instance\\(a $var_a$) (k $var_k$)),\\li $\rightarrow$ (linklet-instance)]} \\ \hline
				% \end{tabular}
				% %\end{table}
				% \end{adjustbox}

			\end{figure-here}


			\begin{figure-here}
				\begin{todo}[TECH TODO]
					Linklets reduction relation
				\end{todo}

				% \begin{figure}[h!]
				% \footnotesize
				% \begin{mdframed}
				% 	\begin{align*}
				% 	\rcinput{x} \rcrel \rcoutput{\sigma[\rho[x]]}{\rho}{\sigma} \\
				% 	\rcinput{(\textbf{var\dash ref}\; x))} \rcrel \rcoutput{v}{\rho}{\sigma}\; \where x \in \rho, \rho[x] \in \sigma, v = \sigma[\rho[x]], v \neq uninit\\
				% 	\rcinput{(\textbf{var\dash ref/no\dash check}\; x))} \rcrel \rcoutput{v}{\rho}{\sigma}\; \where v = \sigma[\rho[x]] \\
				% 	\rcinput{(\textbf{var\dash set!}\; x\; v)} \rcrel \rcoutput{(void)}{\rho}{\sigma_1} \where \sigma_1 = \sigma[\rho[x]\rightarrow v]\\
				% 	\rcinput{(\textbf{var\dash set/check\dash undef!}\; x\; v)} \rcrel \rcoutput{(void)}{\rho}{\sigma_1} \where \sigma_1 = \sigma[\rho[x]\rightarrow v], x \in \rho\\
				% 	\rcinput{(\textbf{set!}\; x\; v)} \rcrel \rcoutput{(void)}{\rho}{\sigma_1} \where \sigma_1 = \sigma[\rho[x]\rightarrow v]\\
				% 	\\
				% 	\redinput{\bm{\Phi^V}(x_{li},\; x)} \rel \redoutput{v}{\rho}{\sigma} \where v\; =\; \sigma[(\sigma[x_{li}])[x]] \\
				% 	%% \redinput{(\textbf{let\dash inst}\; x\; (v\;x_i)\; p\dash top)} \rel \redoutput{p\dash top}{\rho}{\sigma_1} \where \sigma_1 = \sigma[x\rightarrow \sigma[x_i]] \\
				% 	%% \redinput{(\textbf{seq}\; v_{1}\; \ldots\; v_{n})} \rel \redoutput{v_{n}}{\rho}{\sigma} \\
				% 	\redinput{(\bm{\Phi^I}\; (\lb\; x\; v\; \ldots\; v_{l}))} \rel \redoutput{(v_{l}\; x)}{\rho}{\sigma} \\
				% 	EP\;\llbracket (\bm{\Phi^I}(\lb\; x_{t}\; v_p\; \ldots\; (\textbf{define\dash values}\; (x)\; v)\; l\dash top\; \ldots)) \rrbracket, \rel \redoutput{\bm{\Phi^I}(\lb\; x_{t}\; v_p\; \ldots\; l\dash top\; \ldots)}{\rho_1}{\sigma_1} \\
				% 	\;          &\;\; \where \rho_1 = \rho[x\rightarrow cell],\; \sigma_1 = \sigma[cell\rightarrow v] \\
				% 	\redinput{(\bm{\Phi^I}(\la\; c\dash imps \; c\dash exps \; l\dash top \ldots)\; LI\; \ldots)} \rel \redoutput{(\bm{\Phi^I}(\la\; c\dash imps \; c\dash exps \; l\dash top\; \ldots)\; LI\; \ldots\; \textbf{\#:t}\; x_{t})}{\rho}{\sigma_1} \\
				% 	\;          &\;\; \where x_t \notin \mathit{dom}(\sigma), \sigma_1 = \sigma[x_t\rightarrow (linklet\dash instance)] \\
				% 	EP\;\llbracket (\bm{\Phi^I}(\la\; c\dash imps \; c\dash exps \; l\dash top \ldots)\; LI\; \ldots\; \textbf{\#:t}\; x_{t}) \rrbracket, \rho, \sigma\; \rel \redoutput{(\bm{\Phi^I}(\lb\; x_{t}\; l\dash top\; \ldots))}{\rho_2}{\sigma_1} \\
				% 	\; &\;\; \where \rho_1 = \mathit{V}^I(c\dash imps, (LI\; \ldots), \rho) \\
				% 	\;          &\;\; \hspace{0.4cm} (\rho_2, \sigma_1) = \mathit{V}^E(c\dash exps, x_t, \rho_1, \sigma) \\
				% 	(\textbf{program}\; ((x\;L),(x_1\;L_1)\;\ldots)\;p\dash top), \rho, \sigma &\longrightarrow_{\beta p}\; (\textbf{program}\; ((x_1\;L_1)\;\ldots)\;p\dash top[x := \bm{\Phi^C}(L)]), \rho, \sigma \\ \\
				% 	eval^{\longrightarrow_{\beta p}}(p) &=\; v\; \textbf{if}\; p, (), () \twoheadrightarrow_{\beta p\cup\beta r} \; (\textbf{program}\; ()\;(v\;\_)) \\ \\
				% 	%% \mathit{V}^I : c\dash imps \times (LI\;\ldots) \times \rho &\longrightarrow \rho \\
				% 	%% \mathit{V}^I((\overline{(\overline{(\textbf{Import}\; x_{id}\;x_{int}\;x_{ext})})_n}), (\overline{LI_n}), \rho) &= \rho\overline{[x_{id}\rightarrow LI_n[x_{ext}]]}\\ \\
				% 	%% \mathit{V}^E : c\dash exps \times x \times \rho \times \sigma &\longrightarrow \rho \times \sigma \\
				% 	%% \mathit{V}^E((exp\dash obj\;\ldots), x_t, \rho, \sigma) &= \mathit{P}(exp\dash obj, x_t, \sigma[x_t], \rho, \sigma)\;\ldots\\
				% 	%% \mathit{P}((\textbf{Export}\;x_{id}\;x_{int}\;x_{ext}), x_t, LI_t, \rho, \sigma) &= \begin{cases*}
				% 	%%   \rho_1, \sigma & if $\;x_{ext} \in dom(LI_t)$, \where $\rho_1 = \rho[x_{id}\rightarrow LI_t[x_{ext}]]$ \\
				% 	%%   \rho_1, \sigma_1 & if $\;x_{ext} \notin dom(LI_t)$, \where $\rho_1 = \rho[x_{id}\rightarrow var_{new}]$\\
				% 	%%   \;        &\; \hspace{2.6cm} $var_{new} \notin \sigma$ \\
				% 	%%   \;        &\; \hspace{2.6cm} $\sigma_1 = \sigma[var_{new}\rightarrow uninit,$ \\
				% 	%%     \;        &\; \hspace{3.2cm} $x_t\rightarrow LI_t[x_{ext}\rightarrow var_{new}]]$
				% 	%% \end{cases*} \\
				% 	\end{align*}
				% 	\centering
				% 	\footnotesize $\Phi^V : \textbf{instance\dash variable\dash value}\:,\: \Phi^I : \textbf{instantiate\dash linklet},\:\Phi^C : \textbf{compile\dash linklet}$

				% 	\footnotesize $\mathit{V}^I : \textbf{get  import variables},\: \mathit{V}^E : \textbf{create variables for exports}$
				% 	\caption[ccc]{Reduction Relation \footnotemark}
				% 	\label{fig:reduction}
				% \end{mdframed}
				% \end{figure}

			\end{figure-here}

			\begin{paragraph-here}
				These are all implemented in a PLT Redex model, codes are all in the appendix

				maybe give a GitHub link as well?
			\end{paragraph-here}



	\refstepcounter{section}          % advance the counter
	\section*{\thesection\quad Conclusion}

		\begin{paragraph-here}
			The ability to provide high-level functionalities to runtime is one of the key ideas in improving portability.


			The ability to provide high-level functionalities as callable functions to the hosting virtual machine is one of the key ideas in improving Racket’s portability. A VM that wants to host Racket not only gets the high-level implementations such as the module system, macro system for free, but also gets highly re-usable functionalities that it can integrate the systems it implements, such as the top-level repl example in Figure 16.
		\end{paragraph-here}

		\begin{paragraph-here}
			Interplay between the language and the runtime is cool.


			Moreover, Racket implements and exports abstract functionalities that are tightly coupled with the hosting runtime as well. For instance the expander linklet provides the eval function, which is basically an abstract interpreter for Racket. A VM that hosts Racket can call eval, which interprets Racket code by using the run-time primitives and compile-linklet and instantiate-linklet that are implemented and provided by the VM itself. Therefore, one of the essential nuances of self-hosting Racket with the expander linklet, is that the interaction between the run-time and the expander is a two-way street. The VM implements and uses compile-linklet and instantiate-linklet to import the functions provided by the expander, and the expander provides functions that uses the compile-linklet and instantiate-linklet functions, along with the other run-time primitives as well.
		\end{paragraph-here}

		\begin{paragraph-here}
			Interplay between the language and the runtime is cool. Merge with the previous paragraph.

			For example, the dynamic-require used above (provided by the expander linklet) is a Racket function that dynamically loads a Racket module (if it’s not already loaded) by resolving the module path, finding the source code in the file system, reading and expanding the codes and modifying the namespace registry. The Racket code inside the expander that implements all that, calls run-time primitives such as for file-system support and also calls the compile-linklet and instantiate-linklet for expanding and instantiating all the required modules. eval works in a similar fashion as well. This intertwined nature of the high-level language facilities and the low-level run-time support is central to the Racket’s improved portability.
		\end{paragraph-here}



	% This is a figure in landscape orientation
	% \begin{sidewaysfigure}
	% 		\includegraphics[width=\textwidth]{\figPath{pl-portability}/exampleFigure.png}
	% \caption{This is another example Figure, rotated to landscape orientation.}
	% \label{LandscapeFigure}
	% \end{sidewaysfigure}
