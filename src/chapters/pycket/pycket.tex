\chapter[\texorpdfstring{FROM RUDIMENTARY INTERPRETER TO FULL LANGUAGE IMPLEMENTATION}
                          {4. Pycket as Full Racket}]{FROM RUDIMENTARY INTERPRETER TO FULL LANGUAGE IMPLEMENTATION}
	\label{chapter:pycket}

	\begin{chaptersynopsis}

        Languages can influence the capabilities of the run-time they are implemented on.

		Concrete realization of self-hosting of Racket on Pycket.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Implementing Linklets on Pycket

			This is how Pycket is enhanced to interface with linklets. Representation choices, etc.

			\item Enhancing Run-time with Bootstrapping Linklets

			Importing functionality straight from the language in the form of linklets allows the language to shape the behavior of the run-time.

			\item From Rudimentary Interpreter to Full Language Implementation

			Pycket becomes a full working Racket, proving the self-hosting hypothesis.

		\end{itemize}
    \end{chaptersynopsis}

	\paragraph{}% 1
		Languages can influence and enhance the capabilities of the run-time environments or \glspl{vm} they are implemented on. This influence is evident in mature language implementations such as Smalltalk's Squeak, Erlang's OTP on the BEAM \gls{vm}, and Common Lisp's CLOS Meta-Object Protocol (MOP). For example, Smalltalk allows core image manipulation within Smalltalk itself, extending \gls{vm} semantics dynamically \cite{squeak_smalltalk_vm}. Erlang uses its OTP libraries written in Erlang to dynamically control crucial runtime semantics like process scheduling and fault tolerance \cite{erlang_otp_hpc}. Similarly, Common Lisp employs the CLOS MOP to redefine fundamental object system semantics at runtime without altering the native runtime \cite{clos_overview_mop}.

	\paragraph{}% 2
		While the extent of language influence on the runtime varies considerably, Racket's linklets stand out by enabling the language to self-host itself. Linklets can carry crucial Racket subsystems, including the macro expander, the module system, and essential runtime components, to be expressed and distributed as language-level constructs that are supported by a thin primitive layer by the \gls{vm}. This mechanism significantly reduces dependency on the underlying runtime, thereby simplifying portability across different \glspl{vm}.

	\paragraph{}% 3
		Recall Pycket from \secref{section:pycket-primer}, initially introduced as a rudimentary interpreter for Racket, lacking significant capabilities required to independently execute real-world Racket programs. Pycket's initial design relied on the existing Racket executable to read and expand Racket modules before evaluation, highlighting its dependence on external functionality. In contrast, a \emph{full language implementation} refers to an environment capable of independently performing all necessary tasks required to load and execute programs written in that language. Such implementation can read source code, expand macros (load languages), evaluate modules, and provide the full spectrum of runtime facilities, such as a \gls{repl}, error handling, I/O operations, and more, without external assistance.

	\paragraph{}% 5
		Building upon the concepts introduced in \chapterRef{chapter:linklets}, this chapter presents concrete implementation details that transition Pycket from a rudimentary interpreter into a fully operational Racket implementation. By incorporating linklets, Pycket gains the ability to independently load, expand, and evaluate Racket modules, thus substantiating the self-hosting hypothesis outlined earlier. The following sections elaborate on the representation and implementation choices involved in this transition, highlighting runtime enhancements.

	\section[\texorpdfstring{Implementing Linklets on Pycket}{Linklets on Pycket}]{Implementing Linklets on Pycket}

		\paragraph{}% 6
			The first step in establishing an interface with linklets is to define their internal representation. Recall that the linklet design itself does not mandate a particular representation, leaving the decision to the runtime implementer. Chez Scheme, for example, represents linklets as first-class functions. Pycket, in contrast, represents both linklets and linklet instances as first-class Racket values using the custom \pycketcode{W_Linklet} and \pycketcode{W_LinkletInstance} classes, both derived from \pycketcode{W_Object} (the parent abstract class representing Racket values). \figref{fig:pycket-linklet-representation} lists the class definitions of linklets and linklet instances in Pycket. This choice facilitates seamless integration and leverages Pycket’s existing object model.

		\inputFigure{pycket}{pycket-linklet-representation-figure}

		\paragraph{}% 7
			For linklet variables, Pycket employs a specialized AST node named \pycketcode{interpreter.LinkletVar}, which evaluates to heap-allocated cells (\pycketcode{W\_Cell} objects) rather than separate dedicated runtime values. This approach allows the trace optimizer to perform effective optimizations on the top-level environment. Using cells for linklet variables also makes it possible to leverage specialized strategies implemented for cells, such as type specialization and inline caching, thus enhancing runtime efficiency. Consequently, these representation choices significantly influence the design and implementation of \emph{compile-linklet} and \emph{instantiate-linklet}, as these functions directly manifest the runtime’s internal representation for linklets.

		\paragraph{}% 8
			The \emph{compile-linklet} function transforms a linklet expressed as an s-expression into a runnable linklet object, following the formal semantics described in \secref{section:linklet-formal-semantics}. It begins by analyzing the s-expression through multiple passes to identify identifiers defined or mutated within the linklet body. Next, it processes the identifiers for imports and exports, creating runtime objects (\emph{Import} and \emph{Export}) and generating (via \emph{gensym}) fresh identifiers for internal use as needed. Finally, it recursively converts the linklet body into an RPython \gls{ast}, encapsulating all this information within a \pycketcode{W_Linklet} object ready for instantiation.

		\paragraph{}% 9
			The first phase of linklet compilation involves handling imports and exports. Each import specification, kept in a linklet as \pycketcode{[Import ...]} as seen in \figref{fig:pycket-linklet-representation-figure}, references a specific imported instance, with each \pycketcode{Import} object corresponding to a variable provided by that instance. If the linklet specifies distinct names for external (provided by the imported instance) and internal (used within the linklet body) references, these mappings are recorded explicitly within an \pycketcode{Import} object. Likewise, exports are treated similarly; each exported variable may have separate external and internal identifiers, the former visible to importing linklets and the latter used internally within the body. This explicit mapping simplifies variable management and prevents naming conflicts across linklet boundaries.

		\paragraph{}% 10
			After imports and exports are handled, the compilation proceeds with processing the linklet body. Initially, it identifies all targets of \pycketcode{set!} expressions and variables introduced by \pycketcode{define-values} forms. Subsequently, each form within the body is individually compiled from s-expression to Pycket \gls{ast}. Most compilation rules follow straightforward translations, with the notable exceptions involving linklet-variable-specific forms—such as \pycketcode{variable-ref}, \pycketcode{variable-set!}, and related variations—rules of which are detailed in \tableRef{table:linklet-compilation-rules} in \chapterRef{chapter:linklets}. These forms explicitly handle interactions with linklet variables, ensuring correct runtime semantics during instantiation.

		\paragraph{}% 12
			For each top-level defined identifier that's also exported, an additional \pycketcode{variable-set!} form is inserted by the compiler to ensure the correct runtime assignment to the corresponding linklet variable. When an exported identifier appears as a target of a \pycketcode{set!}, the compiler translates the original form into a \pycketcode{variable-set!/check-undefined}, thereby ensuring proper handling of potentially uninitialized variables at runtime. References to exported identifiers that are either undefined at the top level or targeted by a \pycketcode{set!} are explicitly compiled into \pycketcode{variable-ref} forms, enabling dynamic resolution via target instance during instantiation. Finally, references to imported variables are transformed into \pycketcode{variable-ref/no-check} forms. These forms omit runtime existence checks since instantiation will already fail if the variable cannot be imported successfully. Once the entire linklet s-expression has been processed, the \emph{compile-linklet} function outputs a \pycketcode{W_Linklet} object containing all essential runtime information. Specifically, this object includes the prepared \emph{Import} and \emph{Export} mappings, as well as the compiled Pycket \gls{ast} representing the linklet body.

		\paragraph{}% 14
			On the other hand, \emph{instantiate-linklet} performs the actual evaluation of a compiled linklet, implementing the semantics described by the reduction relation in \figref{fig:linklets-reduction-relation}. Initially, it processes the \emph{Import} and \emph{Export} objects, collecting and creating linklet variables accordingly. If the number of instances provided for imports is insufficient, or if any import variable isn't exported by the corresponding input instance, instantiation halts immediately with an error. Next, the function ensures a target instance, either creating a new one during regular instantiation or using an explicitly provided instance during targeted instantiation. Finally, the instantiation proceeds by evaluating the body expressions using the CEK interpreter loop, loading specialized continuation frames (such as \pycketcode{instantiate_def_cont} and \pycketcode{instantiate_val_cont}) that effectively implement the transitive closure of the reduction relation $\longrightarrow_{\beta_p}$. Depending on the instantiation mode, it returns (by applying its own continuation to) either a value or a linklet instance (\racketcode{W_LinkletInstance}).

		\paragraph{}% 16
			Having implemented both \emph{compile-linklet} and \emph{instantiate-linklet}, Pycket gains the capability to independently execute any code expressed in Racket's core language (\pycketcode{#\%kernel}) provided in the form of linklet s-expressions. Together with the internal representations and runtime mechanisms for linklets detailed earlier, these functions establish the foundation that allows Pycket to import and execute Racket’s own runtime extensions, referred to as the bootstrapping linklets. These bootstrapping linklets carry implementations of substantial high-level Racket subsystems—including the macro expander, module system, and other critical runtime components—thereby enabling self-hosting on any runtime environment capable of loading and instantiating linklets. The next section explores the integration and utilization of these bootstrapping linklets within Pycket in detail.

	\section[\texorpdfstring{Enhancing Run-time with Bootstrapping Linklets}{Bootstrapping Linklets}]{Enhancing Run-time with Bootstrapping Linklets}
		% \begin{mainpoint}
		% 	Importing functionality straight from the language in the form of linklets allows the language to shape the behavior of the run-time.
		% \end{mainpoint}

		\paragraph{}% 1
			Bootstrapping linklets, as introduced in \chapterRef{chapter:linklets}, provide a powerful mechanism for encapsulating major Racket subsystems, such as the macro expander, module system, and runtime components, into independently loadable units. By applying the Racket macro expander to any given module (including itself), one can generate a collection of linklets that may then be flattened and merged into a single, standalone linklet s-expression. Using this technique, Racket exposes essential functionalities as separate bootstrapping linklets, notably the expander, IO, threads, and additional utility linklets like fasl and regexp, each of which will be discussed in subsequent subsections.

		\paragraph{}% 3
			With the capabilities provided by \racketcode{compile-linklet} and \racketcode{instantiate-linklet}, Pycket significantly transforms its startup process. Previously, Pycket depended on external tools for reading and expanding modules, as discussed in \secref{section:linklet-motivation}. Now, Pycket is able to independently load the bootstrapping linklets directly into its runtime during initialization, eliminating this dependency and enabling a fully self-contained bootstrapping phase.

		\inputFigure{pycket}{figure-loading-linklet-at-boot}

		\paragraph{}% 4
			\figref{fig:pycket-linklet-loading} illustrates Pycket's process of loading a linklet at startup. Pycket begins by reading the linklet s-expression, then compiles it into a \pycketcode{W_Linklet} object using \racketcode{compile-linklet}. Subsequently, it instantiates this compiled linklet via \racketcode{instantiate-linklet} to produce a linklet instance, which serves as a container holding all variables defined and exported by the linklet. These variables typically represent callable closures and other valid Racket values. Finally, Pycket exposes these variables in its global primitive environment, thereby making Racket-defined values—and more significantly, functions—directly callable from Pycket in a manner indistinguishable from its own primitives implemented in RPython.

		\paragraph{}% 5
			Applying this loading mechanism, Pycket sequentially imports and integrates the bootstrapping linklets in the following order: \emph{regexp}, \emph{thread}, \emph{io}, \emph{fasl}, and \emph{expander}. Each linklet enhances Pycket's runtime environment with specific Racket functionalities, exposing powerful primitives such as \racketcode{read}, \racketcode{write}, \racketcode{expand}, and \racketcode{namespace-require}. \tableRef{table:bootstrapping-linklets} summarizes the size of each linklet and the number of primitives each exposes. Notably, the expander linklet exports fewer primitives than the IO linklet despite having nearly three times as many lines of code.

		\inputFigure{pycket}{table-bootstrapping-linklets-info}

		\paragraph{}% 6
			In addition to standard bootstrapping linklets, Pycket loads a specialized linklet named \pycketcode{pycket_boot}, designed specifically for Pycket's internal use. Previously, Pycket manually invoked Racket’s \racketcode{dynamic-require} primitive from the global primitive environment to initialize the runtime, including loading core languages such as \racketcode{racket/base}. With the availability of the linklet infrastructure, all such startup procedures—previously implemented directly in RPython—can now be written directly in Racket, encapsulated within the \pycketcode{pycket_boot} linklet. This approach significantly simplifies Pycket’s frontend initialization code, integrating setup procedures and configuration parameters like \racketcode{current-library-collection-links}, \racketcode{read-accept-compiled}, and \racketcode{use-compiled-file-paths} entirely at the Racket level.

		\inputFigure{pycket}{figure-new-pycket-frontend-compare-old}

		\paragraph{}% 7
			The integration of the bootstrapping and custom linklets fundamentally transforms Pycket's frontend architecture, as depicted in \figref{fig:pycket-frontend-new-vs-old}. Whereas previously Pycket had to invoke the Racket executable externally to expand Racket modules before evaluation, it now applies Racket's macro expander internally to a given module and evaluates the resulting fully-expanded form-all directly within its CEK core. This architectural shift places all phases of module evaluation—reading, expansion, and execution—fully within Pycket’s runtime, thereby providing self-containment and independence. However, embedding the entire expansion phase internally has substantial implications for runtime performance, a topic examined in depth in \chapterRef{chapter:problem}.

		\paragraph{}% 8
			The bootstrapping linklets provided by Racket depend on primitives supplied by the host runtime—in this case, Pycket. When compiling these linklets, Pycket generates \gls{ast} nodes for each primitive reference. To ensure successful compilation, these primitives must be resolvable within Pycket's global primitive environment. While Pycket already implements a many Racket primitives in RPython—as detailed in \chapterRef{chapter:rpython}—some linklets, notably \emph{thread} and \emph{io}, require additional sub-systems such as engines and a \gls{ffi} layer, which will be discussed further in subsequent sections.

		\inputFigure{pycket}{figure-racket-base-loading-no-compiled}

		\paragraph{}% 9
			Loading bootstrapping linklets into the runtime environment serves as the central mechanism enabling self-hosting. Pycket can read and expand any Racket module by leveraging Racket's own module and macro systems, provided by the expander linklet. For example, loading a language such as \racketcode{#lang racket/base} involves the macro expander and module system generating individual linklets for each required module in its dependency tree. As illustrated in \figref{fig:racket-base-loading-no-compiled}, these modules are compiled and instantiated separately by Pycket. This mechanism is utilized in the next section, where we describe the use of pre-compiled Racket modules to achieve significantly faster startup performance.

		\subsection{Interfacing with the Compiler: Expander Linklet}

			\paragraph{}% 10
				As described in \chapterRef{chapter:linklets}, the expander linklet is generated offline by running the expander on itself, resulting in a serialized s-expression. Pycket reads this serialized s-expression, compiles it into a linklet object using \racketcode{compile-linklet}, and then instantiates it using \racketcode{instantiate-linklet}. Once instantiated, Pycket incorporates all exported functions from the expander—such as \racketcode{read}, \racketcode{expand}, and \racketcode{eval}—into its runtime environment, allowing direct invocation of these functions as native primitives.

			\begin{center}
				\begin{minipage}{0.7\textwidth}
					\begin{lstlisting}[style=inline-python,frame=lines,numbers=none]
	expander_linklet_obj = compile_linklet([expander_linklet_sexp, ...])
	expander_linklet_instance = instantiate_linklet([expander_linklet_obj, ...])
	expander_linklet_instance.expose_vars_to_prim_env()\end{lstlisting}
				\end{minipage}
			\end{center}

			\paragraph{}% 101
				Having direct access to the expander's runtime functions enables Pycket to implement language-level operations such as a top-level \gls{repl} through Racket's own primitives. A minimal implementation of a \gls{repl} can be realized simply by invoking Racket's \racketcode{read}, \racketcode{expand}, and \racketcode{eval} functions within Pycket, as illustrated in the small inline example below. Furthermore, since the expander linklet provides the complete implementations of Racket's macro and module systems, Pycket can directly execute programs written in languages layered on top of the Racket core, such as \racketcode{racket/base}. As a result, instead of implementing a custom \gls{repl}, Pycket can directly apply \racketcode{dynamic-require} to Racket's standard \racketcode{racket/repl} module. This yields a REPL functionally identical to Racket’s own, executed within Pycket’s meta-tracing JIT environment.

			\begin{center}
				\begin{minipage}{0.6\textwidth}
					\begin{lstlisting}[style=inline-python,frame=lines,numbers=none]
				while True:
					r_exp = read.call_racket([repl.readline(), ...])
					r_expanded = expand.call_racket([r_exp, ...])
					result = eval.call_racket([r_expanded, ...])
					print(result)\end{lstlisting}
				\end{minipage}
			\end{center}

			\paragraph{}% 11
				Programs executed through the bootstrapping linklets, including the linklets themselves, often require additional run-time support beyond basic primitives. For instance, running Racket's REPL necessitates implementing delimited continuations at the run-time level. Similarly, handling exceptions originating from Racket code demands robust Racket-level exception handling within Pycket. Pycket's existing implementation provides basic exception handling by translating Racket-level exceptions (implemented as Racket structs) into RPython exceptions. However, fully supporting Racket-level exceptions requires Pycket to handle the installation of exception handlers via continuation marks and dynamically propagate Racket-level exceptions to the appropriate (Racket level) handlers.

			\paragraph{}% 12
				Among the critical functions exposed by the expander linklet are \racketcode{namespace-require}, \racketcode{read}, \racketcode{expand}, and \racketcode{eval}, each of which embodies substantial and complex functionality. \racketcode{eval} functions effectively as an interpreter; \racketcode{namespace-require} implements the core of the module system; and \racketcode{read} and \racketcode{expand} collectively represent the complete macro expander. Thus, the expander linklet itself encapsulates the entire compilation phase required by Racket modules.

			\paragraph{}% 13
				Given the complexity and breadth of these functions—including extensive indirection, numerous cross-module references, and deeply nested loops—the resulting behavior severely complicates tracing and optimization by the meta-tracing JIT. Specifically, the meta-tracer and trace optimizer struggle to generate effective, reusable traces from such highly indirect and dynamic code paths. The \chapterRef{chapter:problem} is dedicated entirely to analyzing the performance implications of this complexity, detailing specific cases and investigating substantial runtime overhead caused by the introduction of these internally evaluated Racket sub-systems.

		\subsection{Interfacing with the Host Environment: IO \& Thread Linklets}

			\begin{paragraph-here}% 131
				Growing into a full implementation also means interacting with the host environment. For this, the thread linklet implements and provides Racket level green (user level) threads, and the io linklet provides the input/output capabilities such as \gls{os} abstractions like files, ports all the way to powerful Racket primitives such as \racketcode{write}. Together they provide more than 300 primitives. IO linklet uses some of the primitives defined in the thread linklet.
			\end{paragraph-here}

			\begin{paragraph-here}% 14
				We mentioned earlier with the expander linklet that some bootstrapping linklets require a bit more support from the hosting runtime because they assume a certain functionality, or they depend on external functionality. Thread linklet requires engines, and IO requires ffi rktio. Also they both define and expose bunch of internal primitives that used to be just stubs on Pycket (e.g. unsafe-start-atomic), now they all work as intended.
			\end{paragraph-here}

			\subsubsection{Thread Linklet}

				\begin{paragraph-here}% 15
					Thread linket defines the Racket level green threads and provides preemption using engines. It defines and exports useful high-level Racket stuff like channels, threads (obviously), futures, and places, as well as powerful low-level stuff like (Racket level) semaphores, custodians, start-atomic \& end-atomic to provide critical section support. Thanks to the enhanced portability via linklets, any run-time that wants to implement Racket doesn't need to worry about how to implement any of these. It is sufficient to implement a minimal primitive support that the linklet requires and all the high-level stuff comes for free.
				\end{paragraph-here}

				\begin{paragraph-here}% 16
					One of those primitive supports for the Thread linklet is engines.

					Engines is a powerful abstraction that abstracts the notion of timed preemption. They provide a low level mechanism that allows time-sharing implementation of arbitrary process abstractions. Therefore, engines itself is not a model for a process abstraction. Rather, it's a model for time-sharing of any process abstraction. Engines are used as the central computation piece within Racket threads. Each thread is given an engine, and given enough \emph{fuel}, the engines carry out the computation that the thread is given. So just like how the engines make the cars go, engines allow threads to go in Racket. They can be interrupted/blocked by either running out of fuel or via an external event. In that case a new engine with the rest of the leftover computation is returned, waiting to be given some fuel and resumed.
					\cite{enginesOriginal}
				\end{paragraph-here}

				\begin{paragraph-here}% 17
					Engines in Racket differentiate Racket level continuations from the host continuations to support full preemption.
					The interruption and resumption is done via what's called \racketcode{meta-continuations}, where the host's notion of continuation is used as a part of logically higher notion of Racket level continuations. Engines operate with meta-continuations that capture a string of host's continuations with the use of prompt tags to delimit the dynamic extend of their computations. Whenever an engine is interrupted, hosts continuation stack needs to be adjusted/unwinded to reflect the abortion of the meta-continuation. And whenever an engine is resumed, the host needs to be able to install the resume meta-continuation saved within the engine created at the interruption.
				\end{paragraph-here}

				\begin{paragraph-here}% 18
					Pycket implements engines to support the Thread linklet. However, Pycket doesn't support full preemption, engines run to completion because RPython assumes a single thread + GIL so we won't ever need true mapping with pthreads anyway. [ELABORATE]
				\end{paragraph-here}

				\begin{paragraph-here}% 181
					With the threads enabled, now everything in Pycket runs in a thread context (\racketcode{call-in-main-thread}), and additional threads are created using that main thread. For example, consider the following interaction in the \gls{repl}.
				\end{paragraph-here}

				\begin{center}
					\begin{minipage}{0.6\textwidth}
						\begin{lstlisting}[style=bashstyle,frame=lines,numbers=none]
						Welcome to Pycket v8.17.0.3
						> (define ch (make-channel))
						> (thread (lambda () (channel-put ch 3)))
						#<thread>
						> (channel-get ch)
						3
						>\end{lstlisting}
					\end{minipage}
				\end{center}

				\begin{paragraph-here}% 182
					This looks like nothing much is happening, but there's some action there. Most interesting one is about that value transfer from the new thread to the main thread (the one running the repl) via a channel. For a channel to transfer a value from a sender thread to a receiver thread, both threads need to be suspended.
					In the repl above:

					The main thread is suspended (by engine-blocking the engine within) for the new thread to run.
					The channel-put in the new thread's body suspends the new thread.
					The value inside the channel is passed through,
					then the new thread resumes and finishes (engine-returned),
					then the main thread is resumed (its engine is invoked again), getting us back to the repl.
				\end{paragraph-here}

				\begin{paragraph-here}% 19
					Threads are also used in the IO linklet as well, which is why the thread linklet is loaded earlier than the IO linklet so when IO linklet's stuff is evaluated (the linklet is instantiated), all the primitives related to the threads from the Thread linklet are ready in the primitive environment.
				\end{paragraph-here}

			\subsubsection{IO Linklet}

				\begin{paragraph-here}% 20
					IO linklet defines the input-output facilities, it exports important abstractions for file system, networking, process management (e.g. subprocesses), exports powerful primitives such as  `write`, as well as defines low-level stuff like handling and encoding of bytes. It uses 49 primitives that are defined and exported by the thread linklet.
				\end{paragraph-here}

				\begin{paragraph-here}% 21
					In order to have such a tight coupling with the underlying \gls{os}, the IO linklet assumes a small layer called \emph{rktio} that's implemented in C. \emph{rktio} is a standalone C library, with more than 200 functions, it provides the backbone of all things in Racket needing system support, e.g. file system, networking, processes, etc.
				\end{paragraph-here}

				\begin{paragraph-here}% 22
					To be able to use the IO linklet, a host (Pycket) needs to load this library and make it available in runtime so the linklet can call those functions. Since Pycket is written in RPython (and most notably, not C), just like Chez Scheme, it constructs this layer by loading rktio via \gls{ffi}. Taking the registry of these functions (rktio.rktl), Pycket automatically generates this layer offline, creating wrapper primitives around every C function and exposees them to the Racket's namespace.
				\end{paragraph-here}

				\begin{paragraph-here}% 23
					Like all ffi implementations, Pycket needs to establish a mapping of representations across both sides of the ffi. Just to be clear, we have struct and primitive types in C that the rktio uses, we have the Pycket types that capture Racket values (\racketcode{W_Object}), and we have RPython rffi layer's primitive types that are translated to C types at code-gen when the \gls{jit} binary is created.

					Here we have three sets of types that we're working with.
						1. rktio types: the types that reside in rktio.rktl that refer by name to
						the actual C types that reside in librktio.a.
						2. rffi (lltype) types that lives in the RPython land.
						3. Pycket (W\_Object) types that are used in Pycket runtime

				\end{paragraph-here}

				\inputFigure{pycket}{rktio-type-mappings}

				\begin{paragraph-here}% 25
					\tableRef{table:rktio-type-mappings} shows some of the notable type mapping between rktio - pycket - rffi.
					Aside from the flat type mappings, there's a small \gls{abi} between rktio and Racket regarding the pointers to memory that the host needs to respect. rktio layer recognizes memory chunks that are opaque (that the rktio refers with \emph{ref}) vs transparent (that the rktio refers with \emph{*ref}) to Racket. Opaque to Racket memory chunks are easy, Pycket uses a generic \pycketcode{rffi.VOIDP}, we just pass around C-pointers in Racket layer, and Pycket doesn't need to know anything about the size of the contents of the memory that the pointer is pointing to.. However, transparent to Racket memory space requires a bit attention by the host. Transparent to Racket memory means the memory is owned (created and managed) by Racket, so no C function tries to free that kind of space. For example, a rktio C function can take `(*ref char)` type input for a buffer it wants to write into-via in-place mutation-, which is a pointer to a byte string. Since `*ref` signifies that the memory is managed by Racket, Racket then can pass a bytes object directly to such function. Therefore the host (Pycket in our case) needs to respect this, and make sure the mutations that the C function is reflected back to the whatever representation the host uses for bytes (W\_MutableBytes in Pycket's case).
				\end{paragraph-here}

				\begin{paragraph-here}%26
					[COMPOSE ALL THE INFO HERE, ORDER DOESN'T MATTER, YOU MAY OMIT SOME DETAILS]

					With this mapping, Pycket generates this entire layer automatically from rktio.rktl.
					With more than 200 functions are generated, along with 26 implemented manually., with *ref mutation reflections, special error handling, the works..

					We have some stuff that we bring from Racketland (the .h header files, as well as the librktio.a static library that contains all the C functions we call. The bootstrap\_structs.py and rktio.py modules contain hand-rolled primitives and struct definitions and form what I call "the connector layer". These are the only primitives that need to know about the layout of certain structs and pointers (to be able to dereference) from rktio. Because, some struct pointers require special treatment because they're accessed (dereferenced) in some of the primitives in the rktio connector layer. For them, we need to generate code that uses its own pointer types at both rffi and pycket. (e.g. rktio\_date\_t is a good example, we have RKTIO\_DATE\_PTR and W\_RKTIO\_DATE\_PTR types that the `rktio\_seconds\_to\_date\_star` dereference after calling rktio\_seconds\_to\_date). Everything else can be opaque to Pycket.
				\end{paragraph-here}


		\subsection{Language Utilities: Fasl \& Regexp Linklets}

			\begin{paragraph-here}% 27
				There's also some linklets exposed by Racket for utility, such as fasl and regexp linklets. These linklets define and provide implementations for the \gls{fasl} and the regular expressions implementations respectively. They are relatively smaller compared to the other linklets, however, their utilities are used extensively in Pycket's frontend and more.. For instance, Pycket uses the \racketcode{fasl->sexp} to load the actual bootstrapping linklets themselves.
			\end{paragraph-here}

			\begin{paragraph-here}% 28
				These functionalities used to exist in Pycket, they were manually implemented in RPython. In fact we'll exploit this for some experiments in the chapter:problem. In there, we provide an in-depth performance comparison between the linklet implementation and the RPython implementation of regexps.
			\end{paragraph-here}

			\begin{paragraph-here}% 30
				These utility linklets actually emphasize the plug-and-play nature of this setup as well.
				With the linklets enabled, we can just plug-in the Racket's implementation for these, so anything that's loaded after that, for example the expander linklet starts using Racket's own regexp implementation for its internal regexp use. If the regexp linklet is not loaded, then the expander naturally uses the RPython implementation. It doesn't know that it's using the RPYthon implementation. The primitives that it calls (such as \racketcode{regexp-match}) from the global primitive environment happen to be exposed by either RPython or the regexp linklet.
			\end{paragraph-here}

	\section[\texorpdfstring{Growing Pycket into Full Racket}{Pycket as Full Racket}]{Growing Pycket into Full Racket}

		\inputFigure{pycket}{welcome-to-pycket}

		\paragraph{}% 1
			With all the bootstrapping linklets successfully loaded into its runtime, Pycket completes its transition into a fully operational, self-hosting Racket implementation. This marks the point where Pycket no longer relies on external Racket executables for critical runtime functionality, as it now internally provides the necessary components—such as macro expansion, module handling, and I/O—required to independently load and run Racket modules. Consequently, Pycket now fulfills the self-hosting hypothesis introduced earlier.

		\paragraph{}% 2
			Pycket's enhanced front-end supports a variety of execution modes, including directly running a provided \texttt{.rkt} source file or launching an interactive session to start the Racket \gls{repl}, as illustrated in \figref{fig:welcome-to-pycket}. These capabilities demonstrate that Pycket integrates core Racket functionality via bootstrapping linklets and seamlessly exposes standard user-facing features. Furthermore, as new features are added to Racket itself, Pycket can readily incorporate them by simply running the corresponding Racket modules. This capability ensures Pycket remains robust and future-proof as a complete implementation of the language.

		\paragraph{}% 3
			The \gls{repl} provided by Pycket here is not custom-written; rather, it is the standard Racket \gls{repl} module (\texttt{racket/repl}), which Pycket dynamically loads by calling \pycketcode{dynamic-require} (provided by the expander linklet) at startup. Running the \gls{repl} necessitates loading the entire \texttt{racket/base} language immediately prior to executing Racket’s \gls{repl} implementation, thereby demonstrating Pycket's capability to independently expand and evaluate sophisticated Racket language modules directly within its runtime.

		\inputFigure{pycket}{figure-racket-base-loading-with-compiled}

		\paragraph{}% 4
			\figref{fig:racket-base-loading-with-compiled} illustrates loading the \texttt{racket/base} language during Pycket's startup with debug output enabled. Notably, the individual modules previously loaded explicitly via linklets no longer appear in this process (compare with \figref{fig:racket-base-loading-no-compiled}). This change occurs because Pycket leverages the \pycketcode{write} and \pycketcode{fasl} functionalities provided by Racket to serialize loaded modules into compiled \texttt{.zo} files. A \texttt{.zo} file is Racket-specific bytecode stored in fasl format. By supplying the Racket parameter \pycketcode{(use-compiled-file-paths compiled/pycket)} to the module system at boot time, Pycket loads these serialized modules directly into memory, bypassing the expensive linklet compilation and instantiation steps. This optimization significantly reduces the loading time of \texttt{racket/base}—from approximately 2 minutes down to about 7 seconds—achieving around a 95\% improvement in startup performance.

		\paragraph{}% 5
			Moreover, the availability of the expander linklet enables Pycket to execute higher-level languages built on top of \texttt{racket/base}, such as the full \texttt{\#lang racket}. For example, consider the Racket program shown in \figref{fig:racket-contract-example}, which utilizes Racket contracts. This program cannot run directly using only \texttt{racket/base}, as it requires additional modules from full Racket. However, Pycket successfully executes it, demonstrating its capability to load and evaluate sophisticated language-level constructs and further validating its status as a complete Racket implementation.

		\inputFigure{pycket}{racket-contract-example}

		\paragraph{}% 6
			With this, we conclude the first part of our thesis statement, the self-hosting hypothesis. We demonstrated concretely that it is possible to evolve a rudimentary interpreter into a full-featured, self-hosting implementation of a functional programming language on a meta-tracing \gls{jit} compiler. In the subsequent chapters, we will discuss how correctness of these developments is ensured, examine performance characteristics of the resulting system, investigate a fundamental performance issue uncovered in this self-hosting setup, and finally propose and evaluate several approaches to address this issue.


% \begin{figure}[h!]
%   \centering
% \includegraphics[scale=0.3]{img/new-pycket-yatay}
% \caption{Pycket now uses the functionalities from the expander linklet to expand and run a given module.}
% \label{fig:new-pycket}
% \end{figure}


