\chapter[\texorpdfstring{LANGUAGE-ENHANCED RUN-TIMES}
                          {4. Pycket as Full Racket}]{LANGUAGE-ENHANCED RUN-TIMES}
	\label{chapter:pycket}

	\begin{chaptersynopsis}

        Languages can influence the capabilities of the run-time they are implemented on.

		Concrete realization of self-hosting of Racket on Pycket.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Implementing Linklets on Pycket

			This is how Pycket is enhanced to interface with linklets. Representation choices, etc.

			\item Enhancing Run-time with Bootstrapping Linklets

			Importing functionality straight from the language in the form of linklets allows the language to shape the behavior of the run-time.

			\item From Rudimentary Interpreter to Full Language Implementation

			Pycket becomes a full working Racket, proving the self-hosting hypothesis.

		\end{itemize}
    \end{chaptersynopsis}

	\begin{paragraph-here}% 1
		Languages that influence/enhance their run-times/VMs that implement them.

		\begin{todo}[TECH TODO]
			fidn some examples for this
		\end{todo}
	\end{paragraph-here}

	\begin{paragraph-here}% 2
		Some are greater than others. With Racket's linklets, self-hosting is possible.
	\end{paragraph-here}

	\begin{paragraph-here}% 3
		Recall Pycket from chapter:rpython, a rudimentary interpreter for Racket.	\end{paragraph-here}

	\begin{paragraph-here}% 4
		What does "a full Racket implementation" mean, then?
	\end{paragraph-here}

	\begin{paragraph-here}% 5
		With realizing what we talked about in chapter:linklets, in this chapter we provide implementation details for turning Pycket from a rudimentary interpreter into a working full Racket implementation
	\end{paragraph-here}

	\section[\texorpdfstring{Implementing Linklets on Pycket}{Linklets on Pycket}]{Implementing Linklets on Pycket}

		\begin{mainpoint}
			This is how Pycket is enhanced to interface with linklets. Representation choices, etc.
		\end{mainpoint}

		\begin{paragraph-here}% 6
			The first step in establishing an interface with linklets is to establish a representation for linklets. In Pycket we represent linklets with a first-class Racket value W\_Linklet class (that's derived from W\_Object) that looks like this.......

			and maybe "because"? like, why did we choose a class, while Chez chose a function..

			Runtimes can represent linklets however they want.

		Chez Scheme represents them as functions, here's how Pycket represents and implements them.
		\end{paragraph-here}

Exploiting the increased portability in Racket, here we turn the
Pycket from being a rudimentary compiler to an implementation of
Racket, independent of the Racket binary. First step is building the
\emph{linklets} layer by implementing the \emph{compile-linklet} and
\emph{instantiate-linklet} functions in RPython, thereby allowing
Pycket to process and evaluate linklets. The \emph{compile-linklet}
takes an s-expression for a linklet to produce a linklet object as
described in \secref{subsec:linklets-semantics}. It makes several
passes on the s-expression to determine the identifiers that are
defined within the linklet and the ones that are mutated. Then it
processes the imported and exported identifiers to produce the Import
and Export run-time objects, freshly generating identifiers (gensym)
as needed. Then it makes a final recursive pass to produce the RPython
AST for the body, and puts all the information within a linklet
object. The \emph{instantiate-linklet} on the other hand, carries out
the steps for running a linklet object. First it processes the Import
and Export objects and collects and creates variables as necessary,
and prepares the target instance (i.e. creates a new instance if it's
a regular instantiation) and interprets the body, effectively
implementing the $\longrightarrow_{\beta p}$ reduction in the \figref{fig:reduction}
which will be transitively applied by the interpreter loop.

		\begin{paragraph-here}% 7
			The representation of linklets directly effect the implementation of `compile-linklet` and `instantiate-linklet`. Recall that the design of linklets doesn't enforce a particular representation, so `compile-linklet` and `instantiate-linklet` are therefore the manifestations of the hosting run-time's representation.
		\end{paragraph-here}

		\begin{paragraph-here}% 8
			`compile-linklet` does this high-level stuff... recall that we introduced its semantics earlier.
		\end{paragraph-here}

		\begin{paragraph-here}% 9
			We start with processing inputs and exports... gensym stuff
		\end{paragraph-here}

		\begin{paragraph-here}% 10
			Then we move on to processing the body. We first make a pass for collecting all the targets of `set!` calls and the ones defined in `define-values` forms. Then we process the body forms one by one. This compilation is largely s-exp->ast, the only interesting cases are the linklet-variable related forms, defined in Table 3.1 in chapter:linklets.
		\end{paragraph-here}

		\begin{paragraph-here}% 11
			Recall that linklet variables are just variables. They're represented with W\_Cell. and W\_Cell are ...............

				check pycketmain for this.
		\end{paragraph-here}

		\begin{paragraph-here}% 12
			For each toplevel defined identifier that's also exported, we emit an additional `variable-set!` form. For every exported identifier that's a target for `set!` we turn the `set!` form into a `variable-set!/check-undefined` form. For every reference to an exported id that's not defined at the toplevel, or one that's a target of a `set!`, we emit a `variable-ref` form. Finally for every reference to an imported variable, we introduce a `variable-ref/no-check` that retrieves a value from a linklet variable without checking existence. We can get away with not checking for the existence of such a variable at run-time because the instantiation would fail if the variable can't be imported to start with.
		\end{paragraph-here}

		\begin{paragraph-here}% 13
			After the whole s-expression for a linklet is processed, the `compile-linklet` outputs a W\_Linklet object that contains.....
		\end{paragraph-here}

		\begin{paragraph-here}% 14
			`instantiate-linklet` does this high-level stuff... essentially implementing the reduction relation in the Figure..
		\end{paragraph-here}

		\begin{paragraph-here}% 15
			It first determines if this is a targeted or regular inst and ensures we have a target instance to work with... Then processes imports and exports.. Finally it goes into the CEK loop, loading its own type of continuations (e.g. instantiate\_def\_cont, instantiate\_val\_cont, etc) to carry out the instantiation, plugging in either a value or an instance to its own continuation depending on the mode of the instantiation.
		\end{paragraph-here}

		\begin{paragraph-here}% 16
			Having `compile-linklet` and `instantiate-linklet` enables Pycket to take any `\#\%kernel` code in the form of a linklet s-expression, and execute it. Together with the linklet representation, they provide the foundation for Pycket to load Racket's own extensions to its runtime that we'll refer to as the bootstrapping linklets. These linklets contain the implementations for major high-level Racket subsystems such as the macro expander and the module system and more that allows the language to self-host on any run-time that can load them. In the next section, we'll explore the details of this.
		\end{paragraph-here}


	\section[\texorpdfstring{Enhancing Run-time with Bootstrapping Linklets}{Bootstrapping Linklets}]{Enhancing Run-time with Bootstrapping Linklets}
		\begin{mainpoint}
			Importing functionality straight from the language in the form of linklets allows the language to shape the behavior of the run-time.
		\end{mainpoint}

		\begin{paragraph-here}% 1
			Recall from that section, that applying Racket macro expander to any Racket module generates linklets for it and those linklets can be flattened into one single linklet. When this is applied to Racket's subsystems such as the module system and a single flat linklet is generated and serialized as a linklet s-expression, a standalone independently loadable linklet is born.
		\end{paragraph-here}

		\begin{paragraph-here}% 2
			With this way, Racket exposes independent linklets for some major components such as the expander, IO, threads, as well as some utility linklets such as fasl and regexp, that we'll talk in detail in the subsections below.
		\end{paragraph-here}

		\begin{paragraph-here}% 3
			Armed with the `compile-linklet` and `instantiate-linklet`, Pycket now can completely transform its front-end to load these linklets into its runtime at boot. We had a related discussion about this in the linklet motivation section.
		\end{paragraph-here}

		\begin{figure-here}
			new figure for loading a linklet at boot in the front-end.. take s-exp, run compile-linklet, expose vars, etc.
		\end{figure-here}

		\begin{paragraph-here}% 4
			Figure shows; after grabbing the s-expression for a linklet, Pycket runs the `compile-linklet` to produce a `W\_Linklet` object. Then it applies `instantiate-linklet` to this linklet object to generate a linklet instance. Recall that a linklet instance is as container for linklet variables. These variables contain everything that this linklet defines and exports. Note that the contents of those variables are valid Racket values, most often callable closures. So all Pycket needs to do to complete loading a linklet is to grab those variables and expose them in the global primitive environment that contains all the primitives that Pycket can pull out and call on demand.
		\end{paragraph-here}

		\begin{table-here}
			linklets, lines of code, number of defined primitives.
		\end{table-here}

		\begin{paragraph-here}% 5
			Applying this method, Pycket loads the regexp, thread, io, fasl, and expander linklets in this order, and exposes all the functions these linklets define. These functions include very powerful Racket functionalities such as `read`, `expand`, `namespace-require`. Table shows the sizes and the number of exposed primitives for each bootstrapping linklet.
		\end{paragraph-here}

		\begin{paragraph-here}% 6
			In addition to these, Pycket also loads an additional linklet called the `pycket\_boot` that's custom made for Pycket to call stuff like `dynamic-require` to start loading Racket languages (e.g. racket/base). Before this linklet, Pycket used to manually pull Racket's `dynamic-require` from the global primitive environment (the expander linklet exposed it in there) and call it synthetically. This also includes some setup functions/parameters on Racket level such as `current-library-collection-links` , `read-accept-compiled`, `use-compiled-file-paths`, etc. Now that we have the capability of loading linklets, all that front-end code that was used to be in RPython can be written in Racket and loaded as a linklet.
		\end{paragraph-here}

		\begin{figure-here}
			 New Pycket workflow, compare with Old Pycket figure
		\end{figure-here}

		\begin{paragraph-here}% 7
			 Figure shows the comparison with the old front-end vs the new front-end. Pycket now can apply the macro expander in-house (as opposed to running the Racket binary) to a given Racket module to fully expand and run it on the CEK core.
		\end{paragraph-here}

		\begin{paragraph-here}% 8
			Loading these linklets require additional runtime support, and a lot of primitives to be provided by Pycket.
		\end{paragraph-here}

		\begin{figure-here}
			 show loading screen for a given program in racket/base...
		\end{figure-here}

		\begin{paragraph-here}% 9
			This is the central mechanism in self-hosting. Being able to do this means Pycket is able to read and expand any Racket module because it can utilize the module system and the macro system to load all the Racket modules that a language such as `\#lang racket/base` might require. Figure shows all the modules being loaded for racket/base.
		\end{paragraph-here}

		\subsection{Interfacing with the Compiler: Expander Linklet}

		\subsection{Interfacing with the Host Environment: IO \& Thread Linklets}
			\begin{todo}[TODO]
				rktio
			\end{todo}
			\begin{todo}[TODO]
				engines
			\end{todo}
		\subsection{Language Utilities: Fasl \& Regexp Linklets}

	\section[\texorpdfstring{From Rudimentary Interpreter to Full Language Implementation}{Pycket as Full Racket}]{From Rudimentary Interpreter to Full Language Implementation}

		\begin{mainpoint}
            Pycket becomes a full working Racket, proving the self-hosting hypothesis.

			\textit{Self-hosting of full-scale functional languages on meta-tracing just-in-time (JIT) compilers is achievable.}
        \end{mainpoint}

        \begin{todo}
			A rudimentary interpreter can be bootstrapped into a full language implementation by importing linklets into the run-time.
		\end{todo}

		\begin{todo}[Import]
			Section 3.3 Making Pycket an Independent Self-Hosting Racket of the proposal document is relevant for this section.
		\end{todo}

Recall from \secref{section:pycket-primer} that Pycket uses Racket binary.
\figref{fig:old-pycket-workflow-vertical}



After implementing the \emph{compile-linklet} and
\emph{instantiate-linklet}, the next step is to load the bootstrapping
linklets into the run-time as described in
\secref{subsec:racket-expand}.




% \begin{figure}[h!]
%   \centering
% \includegraphics[scale=0.3]{img/new-pycket-yatay}
% \caption{Pycket now uses the functionalities from the expander linklet to expand and run a given module.}
% \label{fig:new-pycket}
% \end{figure}


As we described in \secref{subsec:racket-expand}, the expander linklet
is generated offline by running the expander on itself using the
Racket's executable, and serialized as an s-expression. Pycket, then
reads this s-expression and runs \racketcode{compile-linklet} to produce a
linklet object, which is then instantiated using the
\racketcode{instantiate-linklet}, and the functions from the expander
linklet is load into the run-time. At this point, Pycket has all the
functionalities implemented and exported by the expander, such as
read, expand, eval etc., in its run-time to call.

Having the expander and all the functions that it provides in its
run-time allows Pycket to run a wide variety of Racket programs and
easily implement run-time functionalities. For example, a very simple
implementation of our running example top-level repl can directly use
Racket's read, expand and eval functions, as shown in
\figref{fig:repl-rpython}. The \verb|call_racket| is a wrapper that
handles the setup to call Racket functions within the CEK loop.

Moreover, since the expander provides the implementations of Racket's
macro-system and the module-system, Pycket is able to run programs
that are in languages built on top of Racket core, such as
\emph{racket/base}. Therefore, instead of implementing the top-level
repl itself, Pycket can directly run Racket's own repl, which is
implemented as a \emph{racket/base} program, through the
\racketcode{dynamic-require} function exported by the expander.


These programs, including the bootstrapping linklets themselves often
require additional run-time support such as \emph{correlated} objects
(which are syntax objects without the lexical-content information),
Racket-level exception handling and primitive functions. For example,
running Racket's repl requires delimited continuations. Also handling
exceptions in Racket code in the run-time requires Racket-level
exception handling on Pycket. The existing Pycket implementation has a
rudimentary exception handling mechanism via transforming the
Racket-level exceptions (which are implemented by Racket structs) into
the RPython exceptions. However, having Racket-level exceptions
requires the run-time to support installing Racket-level handlers via
continuation-marks and dynamically pass the Racket-level exceptions to
the appropriate handlers.

Moreover, the Racket itself (including the bootstrapping linklets)
generally relies on a large number ($\sim$1500) of primitives, aroud 900
of which we already have in the existing Pycket implementation. An
additional $\sim$200 primitives need to be implemented, along with the
addition of the run-time liblaray \texttt{\#\%linklet} that will
contain 32 linklet related functions including the
\emph{compile-linklet}, \emph{instantiate-linklet} and
\emph{instance-variable-value}.