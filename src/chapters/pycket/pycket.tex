\chapter[\texorpdfstring{FROM RUDIMENTARY INTERPRETER TO FULL LANGUAGE IMPLEMENTATION}
                          {4. Pycket as Full Racket}]{FROM RUDIMENTARY INTERPRETER TO FULL LANGUAGE IMPLEMENTATION}
	\label{chapter:pycket}

	\begin{chaptersynopsis}

        Languages can influence the capabilities of the run-time they are implemented on.

		Concrete realization of self-hosting of Racket on Pycket.

        \vspace{2em}

        Sections:
		\begin{itemize}
			\item Implementing Linklets on Pycket

			This is how Pycket is enhanced to interface with linklets. Representation choices, etc.

			\item Enhancing Run-time with Bootstrapping Linklets

			Importing functionality straight from the language in the form of linklets allows the language to shape the behavior of the run-time.

			\item From Rudimentary Interpreter to Full Language Implementation

			Pycket becomes a full working Racket, proving the self-hosting hypothesis.

		\end{itemize}
    \end{chaptersynopsis}

	\paragraph{}% 1
		Languages can influence and enhance the capabilities of the run-time environments or \glspl{vm} they are implemented on. This influence is evident in mature language implementations such as Smalltalk's Squeak, Erlang's OTP on the BEAM \gls{vm}, and Common Lisp's CLOS Meta-Object Protocol (MOP). For example, Smalltalk allows core image manipulation within Smalltalk itself, extending \gls{vm} semantics dynamically \cite{squeak_smalltalk_vm}. Erlang uses its OTP libraries written in Erlang to dynamically control crucial runtime semantics like process scheduling and fault tolerance \cite{erlang_otp_hpc}. Similarly, Common Lisp employs the CLOS MOP to redefine fundamental object system semantics at runtime without altering the native runtime \cite{clos_overview_mop}.

	\paragraph{}% 2
		While the extent of language influence on the runtime varies considerably, Racket's linklets stand out by enabling the language to self-host itself. Linklets can carry crucial Racket subsystems, including the macro expander, the module system, and essential runtime components, to be expressed and distributed as language-level constructs that are supported by a thin primitive layer by the \gls{vm}. This mechanism significantly reduces dependency on the underlying runtime, thereby simplifying portability across different \glspl{vm}.

	\paragraph{}% 3
		Recall Pycket from \secref{section:pycket-primer}, initially introduced as a rudimentary interpreter for Racket, lacking significant capabilities required to independently execute real-world Racket programs. Pycket's initial design relied on the existing Racket executable to read and expand Racket modules before evaluation, highlighting its dependence on external functionality. In contrast, a \emph{full language implementation} refers to an environment capable of independently performing all necessary tasks required to load and execute programs written in that language. Such implementation can read source code, expand macros (load languages), evaluate modules, and provide the full spectrum of runtime facilities, such as a \gls{repl}, error handling, I/O operations, and more, without external assistance.

	\paragraph{}% 5
		Building upon the concepts introduced in \chapterRef{chapter:linklets}, this chapter presents concrete implementation details that transition Pycket from a rudimentary interpreter into a fully operational Racket implementation. By incorporating linklets, Pycket gains the ability to independently load, expand, and evaluate Racket modules, thus substantiating the self-hosting hypothesis outlined earlier. The following sections elaborate on the representation and implementation choices involved in this transition, highlighting runtime enhancements.

	\section[\texorpdfstring{Implementing Linklets on Pycket}{Linklets on Pycket}]{Implementing Linklets on Pycket}

		\paragraph{}% 6
			The first step in establishing an interface with linklets is to define their internal representation. Recall that the linklet design itself does not mandate a particular representation, leaving the decision to the runtime implementer. Chez Scheme, for example, represents linklets as first-class functions. Pycket, in contrast, represents both linklets and linklet instances as first-class Racket values using the custom \pycketcode{W_Linklet} and \pycketcode{W_LinkletInstance} classes, both derived from \pycketcode{W_Object} (the parent abstract class representing Racket values). \figref{fig:pycket-linklet-representation} lists the class definitions of linklets and linklet instances in Pycket. This choice facilitates seamless integration and leverages Pycket’s existing object model.

		\inputFigure{pycket}{pycket-linklet-representation-figure}

		\paragraph{}% 7
			For linklet variables, Pycket employs a specialized AST node named \pycketcode{interpreter.LinkletVar}, which evaluates to heap-allocated cells (\pycketcode{W\_Cell} objects) rather than separate dedicated runtime values. This approach allows the trace optimizer to perform effective optimizations on the top-level environment. Using cells for linklet variables also makes it possible to leverage specialized strategies implemented for cells, such as type specialization and inline caching, thus enhancing runtime efficiency. Consequently, these representation choices significantly influence the design and implementation of \emph{compile-linklet} and \emph{instantiate-linklet}, as these functions directly manifest the runtime’s internal representation for linklets.

		\paragraph{}% 8
			The \emph{compile-linklet} function transforms a linklet expressed as an s-expression into a runnable linklet object, following the formal semantics described in \secref{section:linklet-formal-semantics}. It begins by analyzing the s-expression through multiple passes to identify identifiers defined or mutated within the linklet body. Next, it processes the identifiers for imports and exports, creating runtime objects (\emph{Import} and \emph{Export}) and generating (via \emph{gensym}) fresh identifiers for internal use as needed. Finally, it recursively converts the linklet body into an RPython \gls{ast}, encapsulating all this information within a \pycketcode{W_Linklet} object ready for instantiation.

		\paragraph{}% 9
			The first phase of linklet compilation involves handling imports and exports. Each import specification, kept in a linklet as \pycketcode{[Import ...]} as seen in \figref{fig:pycket-linklet-representation-figure}, references a specific imported instance, with each \pycketcode{Import} object corresponding to a variable provided by that instance. If the linklet specifies distinct names for external (provided by the imported instance) and internal (used within the linklet body) references, these mappings are recorded explicitly within an \pycketcode{Import} object. Likewise, exports are treated similarly; each exported variable may have separate external and internal identifiers, the former visible to importing linklets and the latter used internally within the body. This explicit mapping simplifies variable management and prevents naming conflicts across linklet boundaries.

		\paragraph{}% 10
			After imports and exports are handled, the compilation proceeds with processing the linklet body. Initially, it identifies all targets of \pycketcode{set!} expressions and variables introduced by \pycketcode{define-values} forms. Subsequently, each form within the body is individually compiled from s-expression to Pycket \gls{ast}. Most compilation rules follow straightforward translations, with the notable exceptions involving linklet-variable-specific forms—such as \pycketcode{variable-ref}, \pycketcode{variable-set!}, and related variations—rules of which are detailed in \tableRef{table:linklet-compilation-rules} in \chapterRef{chapter:linklets}. These forms explicitly handle interactions with linklet variables, ensuring correct runtime semantics during instantiation.

		\paragraph{}% 12
			For each top-level defined identifier that's also exported, an additional \pycketcode{variable-set!} form is inserted by the compiler to ensure the correct runtime assignment to the corresponding linklet variable. When an exported identifier appears as a target of a \pycketcode{set!}, the compiler translates the original form into a \pycketcode{variable-set!/check-undefined}, thereby ensuring proper handling of potentially uninitialized variables at runtime. References to exported identifiers that are either undefined at the top level or targeted by a \pycketcode{set!} are explicitly compiled into \pycketcode{variable-ref} forms, enabling dynamic resolution via target instance during instantiation. Finally, references to imported variables are transformed into \pycketcode{variable-ref/no-check} forms. These forms omit runtime existence checks since instantiation will already fail if the variable cannot be imported successfully. Once the entire linklet s-expression has been processed, the \emph{compile-linklet} function outputs a \pycketcode{W_Linklet} object containing all essential runtime information. Specifically, this object includes the prepared \emph{Import} and \emph{Export} mappings, as well as the compiled Pycket \gls{ast} representing the linklet body.

		\paragraph{}% 14
			On the other hand, \emph{instantiate-linklet} performs the actual evaluation of a compiled linklet, implementing the semantics described by the reduction relation in \figref{fig:linklets-reduction-relation}. Initially, it processes the \emph{Import} and \emph{Export} objects, collecting and creating linklet variables accordingly. If the number of instances provided for imports is insufficient, or if any import variable isn't exported by the corresponding input instance, instantiation halts immediately with an error. Next, the function ensures a target instance, either creating a new one during regular instantiation or using an explicitly provided instance during targeted instantiation. Finally, the instantiation proceeds by evaluating the body expressions using the CEK interpreter loop, loading specialized continuation frames (such as \pycketcode{instantiate_def_cont} and \pycketcode{instantiate_val_cont}) that effectively implement the transitive closure of the reduction relation $\longrightarrow_{\beta_p}$. Depending on the instantiation mode, it returns (by applying its own continuation to) either a value or a linklet instance (\racketcode{W_LinkletInstance}).

		\paragraph{}% 16
			Having implemented both \emph{compile-linklet} and \emph{instantiate-linklet}, Pycket gains the capability to independently execute any code expressed in Racket's core language (\pycketcode{#\%kernel}) provided in the form of linklet s-expressions. Together with the internal representations and runtime mechanisms for linklets detailed earlier, these functions establish the foundation that allows Pycket to import and execute Racket’s own runtime extensions, referred to as the bootstrapping linklets. These bootstrapping linklets carry implementations of substantial high-level Racket subsystems—including the macro expander, module system, and other critical runtime components—thereby enabling self-hosting on any runtime environment capable of loading and instantiating linklets. The next section explores the integration and utilization of these bootstrapping linklets within Pycket in detail.

	\section[\texorpdfstring{Enhancing Run-time with Bootstrapping Linklets}{Bootstrapping Linklets}]{Enhancing Run-time with Bootstrapping Linklets}
		\begin{mainpoint}
			Importing functionality straight from the language in the form of linklets allows the language to shape the behavior of the run-time.
		\end{mainpoint}

		\begin{paragraph-here}% 1
			Recall from that section, that applying Racket macro expander to any Racket module generates linklets for it and those linklets can be flattened into one single linklet. When this is applied to Racket's subsystems such as the module system and a single flat linklet is generated and serialized as a linklet s-expression, a standalone independently loadable linklet is born.
		\end{paragraph-here}

		\begin{paragraph-here}% 2
			With this way, Racket exposes independent linklets for some major components such as the expander, IO, threads, as well as some utility linklets such as fasl and regexp, that we'll talk in detail in the subsections below.
		\end{paragraph-here}

		\begin{paragraph-here}% 3
			Armed with the `compile-linklet` and `instantiate-linklet`, Pycket now can completely transform its front-end to load these linklets into its runtime at boot. We had a related discussion about this in the linklet motivation section.
		\end{paragraph-here}

		\inputFigure{pycket}{figure-loading-linklet-at-boot}

		\begin{paragraph-here}% 4
			\figref{fig:pycket-linklet-loading} shows; after grabbing the s-expression for a linklet, Pycket runs the `compile-linklet` to produce a `W\_Linklet` object. Then it applies `instantiate-linklet` to this linklet object to generate a linklet instance. Recall that a linklet instance is as container for linklet variables. These variables contain everything that this linklet defines and exports. Note that the contents of those variables are valid Racket values, most often callable closures. So all Pycket needs to do to complete loading a linklet is to grab those variables and expose them in the global primitive environment that contains all the primitives that Pycket can pull out and call on demand.
		\end{paragraph-here}

		\begin{table-here}
			linklets, lines of code, number of defined primitives.

			\begin{todo}[TECH TODO]
				table for bootstrapping linklets
			\end{todo}
		\end{table-here}

		\begin{paragraph-here}% 5
			Applying this method, Pycket loads the regexp, thread, io, fasl, and expander linklets in this order, and exposes all the functions these linklets define. These functions include very powerful Racket functionalities such as `read`, `expand`, `namespace-require`. Table shows the sizes and the number of exposed primitives for each bootstrapping linklet.
		\end{paragraph-here}

		\begin{paragraph-here}% 6
			In addition to these, Pycket also loads an additional linklet called the `pycket\_boot` that's custom made for Pycket to call stuff like `dynamic-require` to start loading Racket languages (e.g. racket/base). Before this linklet, Pycket used to manually pull Racket's `dynamic-require` from the global primitive environment (the expander linklet exposed it in there) and call it synthetically. This also includes some setup functions/parameters on Racket level such as `current-library-collection-links` , `read-accept-compiled`, `use-compiled-file-paths`, etc. Now that we have the capability of loading linklets, all that front-end code that was used to be in RPython can be written in Racket and loaded as a linklet.
		\end{paragraph-here}

		\inputFigure{pycket}{figure-new-pycket-frontend-compare-old}

		\begin{paragraph-here}% 7
			 \figref{fig:racket-base-loading-no-compiled} shows the comparison with the old front-end vs the new front-end. Pycket now can apply the macro expander in-house (as opposed to running the Racket binary) to a given Racket module to fully expand and run it on the CEK core.
		\end{paragraph-here}

		\begin{paragraph-here}% 8
			Loading these linklets require additional runtime support, and a lot of primitives to be provided by Pycket.
		\end{paragraph-here}

		\inputFigure{pycket}{figure-racket-base-loading-no-compiled}

		\begin{paragraph-here}% 9
			This is the central mechanism in self-hosting. Being able to do this means Pycket is able to read and expand any Racket module because it can utilize the module system and the macro system to load all the Racket modules that a language such as `\#lang racket/base` might require. Figure shows all the modules being loaded for racket/base.
		\end{paragraph-here}

		\subsection{Interfacing with the Compiler: Expander Linklet}

			\begin{paragraph-here}% 10
				As we stated before, the implementations within the expander linklet is the central piece in self-hosting.
			\end{paragraph-here}

			\begin{paragraph-here}% 11
				It brings in this many primitives, and it requires this many primitives from the host.
			\end{paragraph-here}

			\begin{todo}[TECH TODO]
				how many primitives from Pycket does the expander require to work?
			\end{todo}

			\begin{paragraph-here}% 12
				Some of the critical functions are `namespace-require`, `read`, `expand`, `eval`, etc..
			\end{paragraph-here}

			\begin{paragraph-here}% 13
				It also brings massive issues to tracing, as we'll discuss in chapter:problem.
			\end{paragraph-here}

		\subsection{Interfacing with the Host Environment: IO \& Thread Linklets}

			\begin{paragraph-here}% 14
				Some bootstrapping linklets require a bit more support from the hosting runtime because they assume a certain functionality or they depend on external functionality. Thread requires engines, and IO requires ffi rktio. Also they both define and expose internal primitives that used to be just stubs on Pycket (e.g. unsafe-start-atomic), now they all work as intended.
			\end{paragraph-here}

			\subsubsection{Thread Linklet}

				\begin{paragraph-here}% 15
					Thread linket defines the Racket level green threads and provides preemption using engines. It exports useful stuff like ....
				\end{paragraph-here}

				\begin{paragraph-here}% 16
					Engines are ..... they differentiate Racket level continnuations from the host continuations.
				\end{paragraph-here}

				\begin{paragraph-here}% 17
					The full preemption is supported via Metacontinuations, which are .......
				\end{paragraph-here}

				\begin{paragraph-here}% 18
					Pycket doesn't support full preemption, engines run to completion because RPython assumes a single thread + GIL.
				\end{paragraph-here}

				\begin{paragraph-here}% 19
					Thread linklet also exports some functions that the IO linklet uses.
				\end{paragraph-here}

			\subsubsection{IO Linklet}

				\begin{paragraph-here}% 20
					IO linklet defines the input-output facilities, it exports important functions such as `write`.
				\end{paragraph-here}

				\begin{paragraph-here}% 21
					rktio is a C library of functions that the IO linklet relies on.
				\end{paragraph-here}

				\begin{paragraph-here}% 22
					The host needs to load this library via ffi and expose all the functions to the Racket runtime.
				\end{paragraph-here}

				\begin{paragraph-here}% 23
					Like all ffi implementations, we need to agree on some representations across the sides of the ffi.
				\end{paragraph-here}

				\begin{table-here}
					type mapping for rktio

					\begin{todo}[TECH TODO]
						rktio type mapping
					\end{todo}
				\end{table-here}

				\begin{paragraph-here}% 24
					Table shows the type mapping between rktio - pycket - rffi. With this mapping, Pycket generates this entire layer automatically from rktio.rktl. This many functions.. error handling, the works........
				\end{paragraph-here}

				\begin{paragraph-here}% 25
					There's a small ABI between rktio and Racket that the host needs to respect. rktio layer recognizes memory chunks that are opaque (`ref`) vs transparent (`*ref`) to Racket. Opaque to Racket memory chunks are easy, we just pass around c-pointers (W\_CPointer in Pycket). Howeever, transparent to Racket memory space requires a bit attention by the host.
				\end{paragraph-here}

				\begin{paragraph-here}% 26
					Transparent to Racket memory means the memory is owned and managed (and freed) by Racket, so no C function tries to free that kind of space. For example, a rktio C function can take `(*ref char)` type input for a buffer it wants to write into-via in-place mutation-, which is a pointer to a byte string. Since `*ref` signifies that the memory is managed by Racket, Racket then can pass a bytes object directly to such function. Therefore the host (Pycket in our case) needs to respect this, and make sure the mutations that the C function is reflected back to the whatever representation the host uses for bytes (W\_MutableBytes in Pycket's case).
				\end{paragraph-here}

		\subsection{Language Utilities: Fasl \& Regexp Linklets}

			\begin{paragraph-here}% 27
				There's also some linklets exposed by Racket for utility, such as fasl and regexp linklets. These linklets define .......
			\end{paragraph-here}

			\begin{paragraph-here}% 28
				These functionalities used to exist in Pycket, implemented in RPython. in fact we'll use this for some experimentts in the chapter:problem
			\end{paragraph-here}

			\begin{paragraph-here}% 29
				Fasl linklet provides a `fasl->s-exp` and `s-exp->fasl`. Regexp linklet impllements regexps in Racket.
			\end{paragraph-here}

			\begin{paragraph-here}% 30
				With the linklets enabled, we can just plug-in the Racket's implementation for these, so anything that's loaded after that, for example the expander linklet starts using Racket's own regexp implementation for its internal regexp use.
			\end{paragraph-here}

	\section[\texorpdfstring{Growing Pycket into Full Racket}{Pycket as Full Racket}]{Growing Pycket into Full Racket}

		\inputFigure{pycket}{welcome-to-pycket}

		\begin{paragraph-here}% 1
			With all the bootstrap linklets loaded into its runtime, Racket's self-hosting on Pycket is now complete and ready to run some Racket code.
		\end{paragraph-here}

		\begin{paragraph-here}% 2
			Pycket's front-end allows it to be run with many options, including running a rkt file, as well as with no option to load the Racket repl, which you can see in the FIGURE above.
		\end{paragraph-here}

		\begin{paragraph-here}% 3
			The REPL is Racket's repl, we didn't write any code for it. And it needs the racket/base.
		\end{paragraph-here}

		\inputFigure{pycket}{figure-racket-base-loading-with-compiled}

		\begin{paragraph-here}% 4
			The figure shows the loading of the repl with racket/base with some debug output. Note that we don't see anymore the modules that were being loaded via linklets in the figure we showed earlier. That's because Pycket utilizes the `write` and `fasl` functions to serialize the Racket modules into compiled `.zo` files. `.zo` is a Racket specific compiled bytecodes that's in fasl format. Just like, Racket, by providing the parameter `(use-compiled-file-paths compiled/pycket)` at boot, Pycket also uses compiled code for loaded Racket modules. Doing that cuts the loading of racket/base by .......\%.
		\end{paragraph-here}

		\begin{paragraph-here}% 5
			Furthermore, thanks to the expander linklet, Pycket can run further languages, such as `\#lang racket`. Consider the following program in FIGURE that uses contracts. That can't work in racket/base because of the contracts, and need full Racket. It works on Pycket.
		\end{paragraph-here}

		\inputFigure{pycket}{racket-contract-example}

		\begin{paragraph-here}% 6
			We therefore conclude the first part of our thesis statement, the self-hosting hypothesis, and demonstrated that a rudimentary interpreter can be enhanced into a full language implementation, thereby proving that it is indeed possible to have a self-hosting full-scale functional programming language on a meta-tracing JIT compiler.
			In the next chapter we discuss how we ensure correctness in everything we introduced so far, and in further chapters we study the performance profile and talk about a fundamental issue we uncovered about this self-hosting on meta-tracing, and provide some solution approaches.
		\end{paragraph-here}


% \begin{figure}[h!]
%   \centering
% \includegraphics[scale=0.3]{img/new-pycket-yatay}
% \caption{Pycket now uses the functionalities from the expander linklet to expand and run a given module.}
% \label{fig:new-pycket}
% \end{figure}


As we described in \secref{subsec:racket-expand}, the expander linklet
is generated offline by running the expander on itself using the
Racket's executable, and serialized as an s-expression. Pycket, then
reads this s-expression and runs \racketcode{compile-linklet} to produce a
linklet object, which is then instantiated using the
\racketcode{instantiate-linklet}, and the functions from the expander
linklet is load into the run-time. At this point, Pycket has all the
functionalities implemented and exported by the expander, such as
read, expand, eval etc., in its run-time to call.

Having the expander and all the functions that it provides in its
run-time allows Pycket to run a wide variety of Racket programs and
easily implement run-time functionalities. For example, a very simple
implementation of our running example top-level repl can directly use
Racket's read, expand and eval functions, as shown in
\figref{fig:repl-rpython}. The \verb|call_racket| is a wrapper that
handles the setup to call Racket functions within the CEK loop.

Moreover, since the expander provides the implementations of Racket's
macro-system and the module-system, Pycket is able to run programs
that are in languages built on top of Racket core, such as
\emph{racket/base}. Therefore, instead of implementing the top-level
repl itself, Pycket can directly run Racket's own repl, which is
implemented as a \emph{racket/base} program, through the
\racketcode{dynamic-require} function exported by the expander.


These programs, including the bootstrapping linklets themselves often
require additional run-time support such as \emph{correlated} objects
(which are syntax objects without the lexical-content information),
Racket-level exception handling and primitive functions. For example,
running Racket's repl requires delimited continuations. Also handling
exceptions in Racket code in the run-time requires Racket-level
exception handling on Pycket. The existing Pycket implementation has a
rudimentary exception handling mechanism via transforming the
Racket-level exceptions (which are implemented by Racket structs) into
the RPython exceptions. However, having Racket-level exceptions
requires the run-time to support installing Racket-level handlers via
continuation-marks and dynamically pass the Racket-level exceptions to
the appropriate handlers.

Moreover, the Racket itself (including the bootstrapping linklets)
generally relies on a large number ($\sim$1500) of primitives, aroud 900
of which we already have in the existing Pycket implementation. An
additional $\sim$200 primitives need to be implemented, along with the
addition of the run-time liblaray \texttt{\#\%linklet} that will
contain 32 linklet related functions including the
\emph{compile-linklet}, \emph{instantiate-linklet} and
\emph{instance-variable-value}.