%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Do not edit these lines unless you wish to customize
% the template
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newgeometry{left=1in}

\begin{center}

\yourName\\
\MakeUppercase{\thesisTitle}

\end{center}

\vspace{-2.7\baselineskip}

%Insert your abstract here

\begin{abstract}

Self-hosting a full-scale, higher-order functional language on a meta-tracing
just-in-time (JIT) compiler promises portable, high-performance
implementations, yet prior work remains confined to toy subsets. This
dissertation shows, for the first time, that an \emph{unmodified} Racket
ecosystem can run atop Pycket, a meta-tracing JIT, while preserving
semantic fidelity and practical usability.

The key insight is to let the language itself steer its own runtime.
Using \emph{linklets}—formally specified compilation units encapsulating code,
mutable state, and import/export contracts—we grow a minimal Pycket kernel
into a complete Racket runtime. Untouched Racket functionality are incrementally
imported as linklets, and validated by operational-semantics test
suites, Redex equivalence checks, and a comprehensive coverage.

Performance evaluation reveals two fundamental obstacles: interpreter-shaped
control flow yields overspecialized, non-reusable traces, and compile-time
expansion lacks the tight loops that meta-tracing rewards. Although overall
slowdown is modest, branch-heavy programs inflate warm-up costs, deepen
continuation chains, and increase garbage-collection pressure.

To address these issues we prototype hot-branch detection, and introduce a hybrid CEK + stackful
evaluation model that trims memory footprint. Together, these techniques
promise to narrow the performance gap and chart a research path for making
meta-tracing JITs hospitable to self-hosting languages. Beyond the concrete
system, the work reframes the runtime as a language-defined artifact
and offers a versatile platform for future studies on language–runtime
co-design and tracing-compiler optimization.

\end{abstract}



% \ifdefined\committeeMemberFourTypedName

% \null\hfill \myRule\\
% \null\hfill \committeeChairpersonTypedName, \committeeChairpersonPostNominalInitials\\
% \null\hfill \myRule\\
% \null\hfill \committeeMemberTwoTypedName, \committeeMemberTwoPostNominalInitials\\
% \null\hfill \myRule\\
% \null\hfill \committeeMemberThreeTypedName, \committeeMemberThreePostNominalInitials\\
% \null\hfill \myRule\\
% \null\hfill \committeeMemberFourTypedName, \committeeMemberFourPostNominalInitials\\

% \ifdefined\committeeMemberFiveTypedName
% \null\hfill \myRule\\
% \null\hfill \committeeMemberFiveTypedName, \committeeMemberFivePostNominalInitials\\
% \fi

% \fi
% \restoregeometry
