%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Do not edit these lines unless you wish to customize
% the template
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\newgeometry{left=1in}

\begin{center}

\yourName\\
\MakeUppercase{\thesisTitle}

\end{center}

\vspace{-2.7\baselineskip}

%Insert your abstract here

\begin{abstract}

Self-hosting represents a significant milestone in the evolution of a programming language, indicating its semantic maturity and offering practical advantages in portability and flexibility. While self-hosting is traditionally achieved through meta-circular interpreters or custom compilers, the viability of using meta-tracing \gls{jit} compilers for this purpose in full-scale functional languages remains underexplored. This dissertation investigates this open question by developing an operational self-hosting full Racket implementation on Pycket, a meta-tracing \gls{jit} compiler generated on the RPython framework. We integrate Racket's runtime subsystems into Pycket using linklets--formally specified compilation units that enable self-hosting. To support and clarify this integration, we present formal operational semantics for linklets, validated via both Racket \& Pycket reference implementations and a PLT Redex model. Our evaluation identifies specific performance challenges fundamental to self-hosting on meta-tracing, such as overspecialized traces and increased \gls{gc} overhead. We propose and explore targeted approaches to address these challenges, including methods to guide the tracer away from inefficient trace generation and a hybrid evaluation model combining CEK and stack-based interpreters to reduce memory overhead. Beyond demonstrating the feasibility of efficient self-hosting on meta-tracing \gls{jit} compilers, our findings offer insights into language-runtime co-design, suggesting a general strategy for implementing high-level language features without compromising run-time performance, thereby opening new avenues for further research into efficient language implementation techniques.

\end{abstract}



% \ifdefined\committeeMemberFourTypedName

% \null\hfill \myRule\\
% \null\hfill \committeeChairpersonTypedName, \committeeChairpersonPostNominalInitials\\
% \null\hfill \myRule\\
% \null\hfill \committeeMemberTwoTypedName, \committeeMemberTwoPostNominalInitials\\
% \null\hfill \myRule\\
% \null\hfill \committeeMemberThreeTypedName, \committeeMemberThreePostNominalInitials\\
% \null\hfill \myRule\\
% \null\hfill \committeeMemberFourTypedName, \committeeMemberFourPostNominalInitials\\

% \ifdefined\committeeMemberFiveTypedName
% \null\hfill \myRule\\
% \null\hfill \committeeMemberFiveTypedName, \committeeMemberFivePostNominalInitials\\
% \fi

% \fi
% \restoregeometry
