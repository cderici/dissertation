\begin{lstlisting}[language=pltredex,
                basicstyle=\ttfamily\scriptsize,
                numbers=none, xleftmargin=2em]
(define-metafunction RC
  ; (expr env store stack-depth) -> (result store stack-depth)
  interpret-stack : e ρ Σ n -> (rc-result Σ n) or exception or convert
  [(interpret-stack (raises e) ρ Σ n) (stuck Σ n)] ; for intermediate errors
  [(interpret-stack (raise-depth) ρ Σ n) (stack-depth-exn n)]
  ; stack overflow
  #;[(interpret-stack e ρ Σ n)
   (rc-result Σ_new n)
   (side-condition
    (and (not (redex-match? RC convert (term e)))
         (not (redex-match? RC x (term e)))
         (not (redex-match? RC v (term e)))
         (>= (term n) 10)
         (begin (printf "overflow converting to cek for ~a -- n : ~a\n" (term e) (term n)) #t)))
   (where (rc-result Σ_new) (run-cek (e ρ Σ ())))]
  [(interpret-stack e ρ Σ n)
   (convert-stack-to-heap e ρ Σ ())
   (side-condition
    (and (not (redex-match? RC convert (term e)))
         (not (redex-match? RC x (term e)))
         (not (redex-match? RC v (term e)))
         (>= (term n) 10)
         (begin (printf "overflow converting to cek for ~a -- n : ~a\n" (term e) (term n)) #t)))]
  ; convert to cek (for a single expression)
  [(interpret-stack (convert-to-cek e) ρ Σ n)
   (rc-result Σ_new n)
   (where (rc-result Σ_new) (run-cek (e ρ Σ ())))]

  ; convert to heap
  [(interpret-stack (convert-stack e) ρ Σ n) (convert-stack-to-heap e ρ Σ ())]
  ; if
  [(interpret-stack (if e_test e_1 e_2) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ... (if-κ e_1 e_2)))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e_test ρ Σ ,(add1 (term n))))]
  ; op
  [(interpret-stack (op v ... e_1 e ...) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ... (op-κ op (v ...) (e ...) ρ)))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e_1 ρ Σ ,(add1 (term n))))]
  ; set!
  [(interpret-stack (set! x e) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ... (set-κ (lookup ρ x))))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e ρ Σ ,(add1 (term n))))]
  ; begin
  [(interpret-stack (begin v ... e_1 e_2 e ...) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ... (seq-κ e_2 e ...)))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e_1 ρ Σ ,(add1 (term n))))]
  ; let-values
  [(interpret-stack (let-values (((x_1) v_1) ... ((x) e) ((x_r) e_r) ...) e_body) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast
                          (κ ... (let-κ (((x_r) e_r) ...)
                                        (x_1 ... x) (v_1 ...) e_body)))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e ρ Σ ,(add1 (term n))))]
  ; letrec-values
  [(interpret-stack (letrec-values-cell-ready
                     (((x) e) ((x_r) e_r) ...) e_body) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast
                          (κ ...
                             (letrec-κ (((x_r) e_r) ...)
                                       x
                                       e_body)))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e ρ Σ ,(add1 (term n))))]
  ; app
  [(interpret-stack ((closure x ... e_body ρ_closure) v_args ... e_arg_1 e_args ...) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast
                          (κ ... (fun-κ (closure x ... e_body ρ_closure) (e_args ...) (v_args ...))))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e_arg_1 ρ Σ ,(add1 (term n))))]
  [(interpret-stack (e_f e_args ...) ρ Σ n)
   (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ... (arg-κ (e_args ...))))
   (where (convert-stack-to-heap e_ast ρ_ast Σ_ast (κ ...))
          (interpret-stack e_f ρ Σ ,(add1 (term n))))]

  ; value
  [(interpret-stack rc-result ρ Σ n) (rc-result Σ n)]
  ; id lookup
  [(interpret-stack x ρ Σ n) ((lookup Σ (lookup ρ x)) Σ n)]
  ; lambda
  [(interpret-stack (lambda (x ...) e) ρ Σ n) ((closure x ... e ρ) Σ n)]
  ; set!
  [(interpret-stack (set! x e) ρ Σ n)
   ((void) (overwrite Σ_1 (lookup ρ x) v) n)
   (where (v Σ_1 n_1) (interpret-stack e ρ Σ ,(add1 (term n))))]
  ; op
  [(interpret-stack (op v ...) ρ Σ n) ((δ (op v ...)) Σ n)]

  [(interpret-stack (op v ... e_1 e ...) ρ Σ n)
   (interpret-stack (op v ... v_1 e ...) ρ Σ_1 n)
   (side-condition (not (redex-match? RC v (term e_1))))
   (where (v_1 Σ_1 n_1) (interpret-stack e_1 ρ Σ ,(add1 (term n))))]


  [(interpret-stack (op v ... e_1 e ...) ρ Σ n)
   (stuck Σ_1 n_1)
   (where (stuck Σ_1 n_1) (interpret-stack e_1 ρ Σ ,(add1 (term n))))]
  [(interpret-stack (op v ... e_1 e ...) ρ Σ n)
   exception
   (where exception (interpret-stack e_1 ρ Σ ,(add1 (term n))))]
  ; begin
  [(interpret-stack (begin v ... e_1 e_2 e ...) ρ Σ n)
   (interpret-stack (begin v ... v_1 e_2 e ...) ρ Σ_1 n)
   (side-condition (not (redex-match? RC v (term e_1))))
   (where (v_1 Σ_1 n_1) (interpret-stack e_1 ρ Σ ,(add1 (term n))))]
  [(interpret-stack (begin v ... e_1 e_2 e ...) ρ Σ n)
   exception
   (where exception (interpret-stack e_1 ρ Σ ,(add1 (term n))))]
  [(interpret-stack (begin v ... e) ρ Σ n) ; tail
   (interpret-stack e ρ Σ n)]
  ; if
  [(interpret-stack (if e_test e_1 e_2) ρ Σ n)
   ,(if (equal? (term v_1) (term false))
        (term (interpret-stack e_2 ρ Σ_1 n)) ;; tail
        (term (interpret-stack e_1 ρ Σ_1 n)))
   (where (v_1 Σ_1 n_1) (interpret-stack e_test ρ Σ n))]
  ; let-values
  [(interpret-stack (let-values (((x) v) ...) e_body) ρ Σ n)
   (interpret-stack e_body (extend ρ (x ...) (cell_addr ...)) (extend Σ (cell_addr ...) (v ...)) n)
   (where (cell_addr ...) ,(variables-not-in (term e_body) (term (x ...))))] ; tail
  [(interpret-stack (let-values (((x_1) v_1) ... ((x) e) ((x_r) e_r) ...) e_body) ρ Σ n)
   (interpret-stack (let-values (((x_1) v_1) ... ((x) v) ((x_r) e_r) ...) e_body) ρ Σ_1 n)
   (side-condition (not (redex-match? RC v (term e))))
   (where (v Σ_1 n_1) (interpret-stack e ρ Σ ,(add1 (term n))))]
  [(interpret-stack (let-values (((x_1) v_1) ... ((x) e) ((x_r) e_r) ...) e_body) ρ Σ n)
   exception
   (where exception (interpret-stack e ρ Σ ,(add1 (term n))))]
  ; letrec-values
  [(interpret-stack (letrec-values (((x) e) ...) e_body) ρ Σ n)
   (interpret-stack (letrec-values-cell-ready (((x) e) ...) e_body)
                    (extend ρ (x ...) (cell_addr ...)) Σ n)
   (where (cell_addr ...) ,(variables-not-in (term (e_body x ...)) (term (x ...))))]

  [(interpret-stack (letrec-values-cell-ready () e_body) ρ Σ n)
   (interpret-stack e_body ρ Σ n)]

  [(interpret-stack (letrec-values-cell-ready (((x_rhs) e_rhs) ((x) e) ...) e_body) ρ Σ n)
   (interpret-stack (letrec-values-cell-ready (((x) e) ...) e_body)
                    ρ (extend Σ_1 ((lookup ρ x_rhs)) (v_rhs)) n)
   ;                                     v-- don't need to extend, the cell is already there
   (where (v_rhs Σ_1 n_1) (interpret-stack e_rhs ρ Σ ,(add1 (term n))))]

  [(interpret-stack (letrec-values-cell-ready (((x) e) ((x_r) e_r) ...) e_body) ρ Σ n)
   exception
   (where cell_addr (lookup ρ x))
   (where exception (interpret-stack e ρ Σ ,(add1 (term n))))]

  ; app
  [(interpret-stack (x_func e ...) ρ Σ n)
   (interpret-stack (v_func e ...) ρ Σ n)
   (where v_func (lookup Σ (lookup ρ x_func)))]

  [(interpret-stack ((closure x ... e_body ρ_closure) v_args ...) ρ Σ n)
   (interpret-stack e_body (extend ρ_closure (x ...) (cell_addr ...)) (extend Σ (cell_addr ...) (v_args ...)) n)
   (where (cell_addr ...) ,(variables-not-in (term e_body) (term (x ...))))]


  [(interpret-stack ((closure x ... e_body ρ_closure) v_args ... e_arg_1 e_args ...) ρ Σ n)
   (interpret-stack ((closure x ... e_body ρ_closure) v_args ... v_arg_1 e_args ...) ρ Σ_1 n)
   (side-condition (not (redex-match? RC v (term e_arg_1))))
   (where (v_arg_1 Σ_1 n_1) (interpret-stack e_arg_1 ρ Σ ,(add1 (term n))))]



  [(interpret-stack ((closure x ... e_body ρ_closure) v_args ... e_arg_1 e_args ...) ρ Σ n)
   exception
   (where exception (interpret-stack e_arg_1 ρ Σ ,(add1 (term n))))]
  [(interpret-stack (e_f e_args ...) ρ Σ n)
   (interpret-stack (v_func e_args ...) ρ Σ_1 n)
   (where (v_func Σ_1 n_1) (interpret-stack e_f ρ Σ ,(add1 (term n))))]
  [(interpret-stack (e_f e_args ...) ρ Σ n)
   exception
   (where exception (interpret-stack e_f ρ Σ ,(add1 (term n))))]
  )

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;; CEK Evaluator
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(define-metafunction RC
  eval-cek : e -> rc-result or exception
  [(eval-cek e) rc-result
                (where (rc-result Σ) (run-cek (e () () ())))]
  [(eval-cek e) exception
                (where exception (run-cek (e () () ())))])

(define-metafunction RC
  run-cek : (e ρ Σ κ) -> (rc-result Σ) or exception
  [(run-cek (rc-result ρ Σ ())) (rc-result Σ)]
  [(run-cek ((convert-to-stackful e) ρ Σ κ))
   (run-cek (e_again ρ Σ_again κ))
   (where (e_again Σ_again)
          (dynamic-eval-stackful e ρ Σ))]
  [(run-cek any_1)
   (run-cek (e_again ρ_again Σ_again κ_again))
   (where ((e_again ρ_again Σ_again κ_again))
          ,(apply-reduction-relation -->cek (term any_1)))]
  [(run-cek any) (stuck ())])


\end{lstlisting}